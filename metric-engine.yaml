# main:  # we now have default values for everything here in the code. Can override on an as-needed basis
# udb: # moved udb-related paths under this top-level key. everything is in programtic defaults in code and can be overridden here

pprof: [ "unix:/run/telemetryservice/http.socket" ]
SSE: [ "unix:/run/telemetryservice/http.socket" ]
Redfish: [ "unix:/run/telemetryservice/http.socket" ,"http::8080"]
pipe: [ "/run/telemetryservice/metric-engine.pipe" ]

persistence:
  topsavedir: "/var/lib/telemetryservice/"
  topimportonlydir: "/usr/share/telemetryservice/"


UDB-Metric-Import:
  CurrentCUPS:
    Type: DirectMetric
    DBChange:
      SHM.db:
        TblsCurrentCUPS:
    ScanInterval: 0
    WaitInterval: 1
    Query: |
      SELECT
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as Context,

        SystemCupsTimeStamp * 1000000000 as Timestamp,
        SystemCupsCurrent as Value,
        'SystemUsage' as Name
      FROM TblsCurrentCUPS
      where Timestamp > :HWM
      UNION ALL

      SELECT
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as Context,

        MemoryCupsTimeStamp * 1000000000 as Timestamp,
        MemoryCupsCurrent as Value,
        'MemoryUsage' as Name
      FROM TblsCurrentCUPS
      where Timestamp > :HWM
      UNION ALL

      SELECT
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as Context,

        IoCupsTimestamp * 1000000000 as Timestamp,
        IoCupsCurrent as Value,
        'IOUsage' as Name
      FROM TblsCurrentCUPS
      where Timestamp > :HWM
      UNION ALL

      SELECT
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as Context,

        CpuCupsCollectionTime * 1000000000 as Timestamp,
        CpuCupsCurrent as Value,
        'CPUUsage' as Name
      FROM TblsCurrentCUPS
      where Timestamp > :HWM

  PowerStatistics:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsPowerStatistics:
    ScanInterval: 0
    # telemetrypop populates this table once per minute, dont scan more frequently than that.
    WaitInterval: 60
    # There is a TblAvgPowerConsumptionStatDataObj, why aren't we using that?
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB - 2020-03-10 - From Sailaja - backend reports every minute
        60000000000 as 'SensorInterval',
        5000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        strftime('%s', LastWeekMinPowerTime, 'unixepoch', 'utc') as 'Metric-LastWeekMinPowerTime',
        LastWeekMinPower as 'Metric-LastWeekMinPower',
        strftime('%s', LastWeekMaxPowerTime, 'unixepoch', 'utc') as 'Metric-LastWeekMaxPowerTime',
        LastWeekMaxPower as 'Metric-LastWeekMaxPower',
        LastWeekAvgPower as 'Metric-LastWeekAvgPower',

        strftime('%s', LastDayMinPowerTime, 'unixepoch', 'utc') as 'Metric-LastDayMinPowerTime',
        LastDayMinPower as 'Metric-LastDayMinPower',
        strftime('%s', LastDayMaxPowerTime, 'unixepoch', 'utc') as 'Metric-LastDayMaxPowerTime',
        LastDayMaxPower as 'Metric-LastDayMaxPower',
        LastDayAvgPower as 'Metric-LastDayAvgPower',

        strftime('%s', LastHourMinPowerTime, 'unixepoch', 'utc') as 'Metric-LastHourMinPowerTime',
        LastHourMinPower as 'Metric-LastHourMinPower',
        strftime('%s', LastHourMaxPowerTime, 'unixepoch', 'utc') as 'Metric-LastHourMaxPowerTime',
        LastHourMaxPower as 'Metric-LastHourMaxPower',
        LastHourAvgPower as 'Metric-LastHourAvgPower',

        strftime('%s', LastMinuteMinPowerTime, 'unixepoch', 'utc') as 'Metric-LastMinuteMinPowerTime',
        LastMinuteMinPower as 'Metric-LastMinuteMinPower',
        strftime('%s', LastMinuteMaxPowerTime, 'unixepoch', 'utc') as 'Metric-LastMinuteMaxPowerTime',
        LastMinuteMaxPower as 'Metric-LastMinuteMaxPower',
        LastMinuteAvgPower as 'Metric-LastMinuteAvgPower'

      FROM TblsPowerStatistics

  PowerMetrics:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsPowerMetrics:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB - 2/7/2020 - observed 5s, 10s, 15s, and 30s intervals. possibly suppressed upstream
        -- setting 5s sensor interval for now
        5000000000 as 'SensorInterval',  -- 5s interval w/ 2s slack
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        TotalStoragePower as 'Metric-TotalStoragePower',
        TotalPciePower as 'Metric-TotalPciePower',
        TotalMemoryPower as 'Metric-TotalMemoryPower',
        TotalFanPower as 'Metric-TotalFanPower',
        TotalCPUPower as 'Metric-TotalCPUPower',
        SystemPwrConsumption as 'Metric-SystemPowerConsumption',
        SystemHeadRoomInstantaneous as 'Metric-SystemHeadRoomInstantaneous',

        -- BUG IN UNDERLYING CODE -> this time stamp is reported in local time!
        -- THIS IS WRONG. WE HAVE TO FIX THIS UP HERE, BUT IT SHOULD BE FIXED IN UNDERLYING CODE
        -- CurrentSystemOutputTimeStamp * 1000000000 as 'Timestamp-SystemOutputPower',
        strftime('%s', CurrentSystemOutputTimeStamp, 'unixepoch', 'utc') as 'Timestamp-SystemOutputPower',
        CurrentSystemOutputPower as 'Metric-SystemOutputPower',

        -- BUG IN UNDERLYING CODE -> this time stamp is reported in local time!
        -- THIS IS WRONG. WE HAVE TO FIX THIS UP HERE, BUT IT SHOULD BE FIXED IN UNDERLYING CODE
        -- CurrentSystemInputPowerTimeStamp * 1000000000 as 'Timestamp-SystemInputPower',
        strftime('%s', CurrentSystemInputPowerTimeStamp, 'unixepoch', 'utc') as 'Timestamp-SystemInputPower',
        CurrentSystemInputPower as 'Metric-SystemInputPower'
      FROM TblsPowerMetrics

  ThermalMetrics:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsThermalMetrics:
    ScanInterval: 0
    # telemetrypop populates this table once per 5sec, changing from 1 sec to 5 sec.
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB - 2020-02-07 - observed 5s, 10s, 15s, 20s, 25s interals. Typical is 5s. Possibly suppressed upstream
        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        TotalPSUHeatDissipation as 'Metric-TotalPSUHeatDissipation',
        SysRackTempDelta as 'Metric-SysRackTempDelta',
        SysNetAirflow as 'Metric-SysNetAirflow',
        SysAirflowUtilization as 'Metric-SysAirflowUtilization',
        SysAirflowPerSysInputPower as 'Metric-SysAirflowPerSysInputPower',
        SysAirflowPerFanPower as 'Metric-SysAirflowPerFanPower',
        SysAirFlowEfficiency as 'Metric-SysAirFlowEfficiency',
        PowerToCoolRatio as 'Metric-PowerToCoolRatio',
        PSUEfficiency as 'Metric-PSUEfficiency',
        ITUE as 'Metric-ITUE',
        ComputePower as 'Metric-ComputePower'
      FROM TblsThermalMetrics

  CPUMem:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsCpuMemMetrics:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB 2020-02-07 - observed mostly reliable 5s intervals. Sometimes 10s. Possibly suppressed upstream
        -- Sailaja 2020-03-11 backend i.e telemetrypop reports every 5s
        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        CpuMemoryMetrics_DOT_NonC0ResidencyLow_DOT_value as 'Metric-NonC0ResidencyLow',
        CpuMemoryMetrics_DOT_NonC0ResidencyHigh_DOT_value as 'Metric-NonC0ResidencyHigh',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthPort3_DOT_value as 'Metric-CUPSIIOBandwidthPort3',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthPort2_DOT_value as 'Metric-CUPSIIOBandwidthPort2',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthPort1_DOT_value as 'Metric-CUPSIIOBandwidthPort1',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthPort0_DOT_value as 'Metric-CUPSIIOBandwidthPort0',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthDMI_DOT_value as 'Metric-CUPSIIOBandwidthDMI',
        CpuMemoryMetrics_DOT_CPUC0ResidencyLow_DOT_value as 'Metric-CPUC0ResidencyLow',
        CpuMemoryMetrics_DOT_CPUC0ResidencyHigh_DOT_value as 'Metric-CPUC0ResidencyHigh'
      FROM TblsCpuMemMetrics

  PSU-Sensor:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsPSUMetrics:
    ScanInterval: 0
    WaitInterval: 60
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        'SHM.db::TblsPSUMetrics::' || ROWID as MVSourceTraceInfo,

        -- MEB 2020-02-07 - observed mostly reliable 5s intervals. Sometimes 10s. Possibly suppressed upstream
        -- Sailaja 2020-03-11 Backend i.e telemetrypop reports every minute.
        60000000000 as 'SensorInterval',  -- 60s interval w/ 5s slack
        5000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        Temperature as 'Metric-TemperatureReading',
        FanSpeed as 'Metric-RPMReading'
      FROM TblsPSUMetrics

  Storage-Sensor:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsStorageSensor:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        'SHM.db::TblsStorageSensor::' || ROWID as MVSourceTraceInfo,

        -- MEB 2020-02-07 - TODO -> Need info from Sailaja about the intervals here
        -- My data set has no recurrence on these values, bug in telemetrypop? Or are they really not changing? Too much suppression happening.
        -- TODO FIXME - going to hardcode this as 20s for now
        -- Sailaja - we need to check this, because backend reports only if there is a change, so should expand happen?
        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        CurrentReading as 'Metric-TemperatureReading'
      FROM TblsStorageSensor

  Memory-Sensor:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsMemorySensor:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        'SHM.db::TblsMemorySensor::' || ROWID as MVSourceTraceInfo,

        -- MEB 2020-02-07 - TODO -> Need info from Sailaja about the intervals here
        -- My data set has no recurrence on these values, bug in telemetrypop? Or are they really not changing? Too much suppression happening.
        -- TODO FIXME - going to hardcode this as 20s for now
        -- Sailaja - we need to check this, because backend reports only if there is a change, so should expand happen?
        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        CurrentReading as 'Metric-TemperatureReading'
      FROM TblsMemorySensor

  FPGA-Sensor:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsFPGASensor:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        'SHM.db::TblsFPGASensor::' || ROWID as MVSourceTraceInfo,

        -- MEB 2020-02-07 - TODO -> Need info from Sailaja about the intervals here
        -- No hardware in MEB test machine. Need info.
        -- TODO FIXME - going to hardcode this as 20s for now
        -- Sailaja - we need to check this, because backend reports only if there is a change, so should expand happen?
        5000000000 as 'SensorInterval',  -- 5s interval w/ 1s slack
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        CurrentReading as 'Metric-TemperatureReading'
      FROM TblsFPGASensor

  Aggregation-Metrics:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsAggregationMetrics:
    ScanInterval: 60
    WaitInterval: 60
    Query: |
      SELECT
        -- only artificial available for now
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        FriendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB 2020-02-07 - observed ~60s regular intervals here, but occasional 5s. WTF?
        -- TODO - investigate sensor interval here
        -- Sailaja - we need to check this, because reportinterval for this is zero & devicepoll is 60 sec?
        60000000000 as 'SensorInterval',
        5000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        SystemMaxPowerConsumption as 'Metric-SystemMaxPowerConsumption',
        SystemMaxInletTempHour as 'Metric-SystemMaxInletTempHour',
        SystemAvgInletTempHour as 'Metric-SystemAvgInletTempHour'
      FROM TblsAggregationMetrics

  SMART-NVME:
    Type: MetricColumns
    DBChange:
      DMLiveObjectDatabase.db:
        TblRAID_PDSmartData_NVMe:
    # underlying table has change support *AND* HWM, so no need to be stingy
    # ScanInterval: 600
    ScanInterval: 30
    WaitInterval: 5
    Query: |
      SELECT
        lastUpdatedDateTime * 1000000000 as Timestamp,
        FQDD as Context,
         '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        3600000000000 as 'SensorInterval',
        60000000000 as 'SensorSlack',
        true as 'RequiresExpand',
        'DMLiveObjectDatabase.db::TblRAID_PDSmartData_NVMe::' || ROWID as MVSourceTraceInfo,

        smartData_DOT_percentageUsed as 'Metric-PercentageUsed',
        smartData_DOT_criticalWarning as 'Metric-CriticalWarning',
        smartData_DOT_compositeTemparature as 'Metric-CompositeTemperature',
        smartData_DOT_compositeTemparature as 'Metric-TemperatureReading',                  -- Add standard TemperatureReading metric
        smartData_DOT_availableSpareThreshold as 'Metric-AvailableSpareThreshold',
        smartData_DOT_availableSpare as 'Metric-AvailableSpare',
        smartData_DOT_UnsafeShutdowns_DOT_Upper as 'Metric-UnsafeShutdownsUpper',
        smartData_DOT_UnsafeShutdowns_DOT_Lower as 'Metric-UnsafeShutdownsLower',
        smartData_DOT_PowerOnHours_DOT_Upper as 'Metric-PowerOnHoursUpper',
        smartData_DOT_PowerOnHours_DOT_Lower as 'Metric-PowerOnHoursLower',
        smartData_DOT_PowerCycles_DOT_Upper as 'Metric-PowerCyclesUpper',
        smartData_DOT_PowerCycles_DOT_Lower as 'Metric-PowerCyclesLower',
        smartData_DOT_NumOfErrorInfoLogEntries_DOT_Upper as 'Metric-NumOfErrorInfoLogEntriesUpper',
        smartData_DOT_NumOfErrorInfoLogEntries_DOT_Lower as 'Metric-NumOfErrorInfoLogEntriesLower',
        smartData_DOT_MediaAndDataIntegrityErrs_DOT_Upper as 'Metric-MediaDataIntegrityErrorsUpper',
        smartData_DOT_MediaAndDataIntegrityErrs_DOT_Lower as 'Metric-MediaDataIntegrityErrorsLower',
        smartData_DOT_HostWriteCmds_DOT_Upper as 'Metric-HostWriteCommandsUpper',
        smartData_DOT_HostWriteCmds_DOT_Lower as 'Metric-HostWriteCommandsLower',
        smartData_DOT_HostReadCmds_DOT_Upper as 'Metric-HostReadCommandsUpper',
        smartData_DOT_HostReadCmds_DOT_Lower as 'Metric-HostReadCommandsLower',
        smartData_DOT_DataUnitsWritten_DOT_Upper as 'Metric-DataUnitsWrittenUpper',
        smartData_DOT_DataUnitsWritten_DOT_Lower as 'Metric-DataUnitsWrittenLower',
        smartData_DOT_DataUnitsRead_DOT_Upper as 'Metric-DataUnitsReadUpper',
        smartData_DOT_DataUnitsRead_DOT_Lower as 'Metric-DataUnitsReadLower',
        smartData_DOT_ControllerBusyTime_DOT_Upper as 'Metric-ControllerBusyTimeUpper',
        smartData_DOT_ControllerBusyTime_DOT_Lower as 'Metric-ControllerBusyTimeLower'
      FROM TblRAID_PDSmartData_NVMe
      WHERE Timestamp > :HWM

  SMART-SAS:
    Type: MetricColumns
    # underlying table has change support *AND* HWM, so no need to be stingy
    #ScanInterval: 600
    ScanInterval: 30
    WaitInterval: 5
    DBChange:
      DMLiveObjectDatabase.db:
        TblRAID_PDSmartData_SAS_SATA:
    Query: |
      SELECT
        lastUpdatedDateTime * 1000000000 as Timestamp,
        FQDD as Context,
         '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        'DMLiveObjectDatabase.db::TblRAID_PDSmartData_SAS_SATA::' || ROWID as MVSourceTraceInfo,

        3600000000000 as 'SensorInterval',
        60000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        smartData_DOT_volatileMemoryBackupSourceFailures as 'Metric-VolatileMemoryBackupSourceFailures',
        smartData_DOT_usedReservedBlockCount as 'Metric-UsedReservedBlockCount',
        smartData_DOT_unusedReservedBlockCount as 'Metric-UnusedReservedBlockCount',
        smartData_DOT_uncorrectableLBACount as 'Metric-UncorrectableLBACount',
        smartData_DOT_uncorrectableErrorCount as 'Metric-UncorrectableErrorCount',
        smartData_DOT_reallocatedBlockCount as 'Metric-ReallocatedBlockCount',
        smartData_DOT_readErrorDate as 'Metric-ReadErrorRate',
        smartData_DOT_programFailCount as 'Metric-ProgramFailCount',
        smartData_DOT_powerOnHours as 'Metric-PowerOnHours',
        smartData_DOT_powerCycleCount as 'Metric-PowerCycleCount',
        smartData_DOT_percentDriveLifeRemaining as 'Metric-PercentDriveLifeRemaining',
        smartData_DOT_mediaWriteCount as 'Metric-MediaWriteCount',
        smartData_DOT_exceptionModeStatus as 'Metric-ExceptionModeStatus',
        smartData_DOT_eraseFailCount as 'Metric-EraseFailCount',
        smartData_DOT_driveTemperature as 'Metric-DriveTemperature',
        smartData_DOT_driveTemperature as 'Metric-TemperatureReading',                        -- Add temperature reading standard metric
        smartData_DOT_currentPendingSectorCount as 'Metric-CurrentPendingSectorCount',
        smartData_DOT_commandTimeout as 'Metric-CommandTimeout',
        smartData_DOT_ECCERate as 'Metric-ECCERate',
        smartData_DOT_CRCErrorCount as 'Metric-CRCErrorCount'
      FROM TblRAID_PDSmartData_SAS_SATA
      WHERE Timestamp > :HWM

  GPU-Statistics:
    Type: MetricColumns
    # SingleRecordEtag is the underlying HWM, so we can scan the table more often
    ScanInterval: 30
    WaitInterval: 1
    DBChange:
      DMLiveObjectDatabase.db:
        TblGPUStatisticsObj:
    Query: |
      SELECT
        SingleRecordEtag * 1000000000 as Timestamp,
        FQDD as Context,
         '/redfish/v1/FIXME/' || FQDD as Property,
        FQDD as FQDD,
        'DMLiveObjectDatabase.db::TblGPUStatisticsObj::' || ROWID as MVSourceTraceInfo,

        600000000000 as 'SensorInterval',
        60000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        SBERetiredPages as 'Metric-SBERetiredPages',
        SBECounterGRTex as 'Metric-SBECounterGRTex',
        SBECounterGRRF as 'Metric-SBECounterGRRF',
        SBECounterGRL1CacheorSHM as 'Metric-SBECounterGRL1CacheorSHM',
        SBECounterFBL2Cache as 'Metric-SBECounterFBL2Cache',
        SBECounterFB as 'Metric-SBECounterFB',
        DBERetiredPages as 'Metric-DBERetiredPages',
        DBECounterGRTex as 'Metric-DBECounterGRTex',
        DBECounterGRTex as 'Metric-DBECounterGRTex',
        DBECounterGRRF as 'Metric-DBECounterGRRF',
        DBECounterGRL1CacheorSHM as 'Metric-DBECounterGRL1CacheorSHM',
        DBECounterFBL2Cache as 'Metric-DBECounterFBL2Cache',
        DBECounterFB as 'Metric-DBECounterFB',
        CumulativeSBECounterGR as 'Metric-CumulativeSBECounterGR',
        CumulativeDBECounterGR as 'Metric-CumulativeDBECounterGR',
        CumulativeDBECounterFB as 'Metric-CumulativeDBECounterFB'
      FROM TblGPUStatisticsObj
      WHERE Timestamp > :HWM



  GPU-Health:
    Type: MetricColumns
    # SingleRecordEtag is the underlying HWM, so we can scan the table more often
    ScanInterval: 10
    WaitInterval: 5
    DBChange:
      DMLiveObjectDatabase.db:
        TblGPUHealthObj:
    Query: |
      SELECT
        SingleRecordEtag * 1000000000 as Timestamp,
        FQDD as Context,
         '/redfish/v1/FIXME/' || FQDD as Property,
        FQDD as FQDD,
        'DMLiveObjectDatabase.db::TblGPUHealthObj::' || ROWID as MVSourceTraceInfo,

        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        CASE BoardPowerSupplyStatus
        WHEN "Not Applicable"  then "Not Applicable"
        WHEN "SufficientPower" then "SufficientPower"
        WHEN "UnderPowered"    then "UnderPowered"
        ELSE null
        END as "Metric-BoardPowerSupplyStatus",

        BoardTemp              as 'Metric-BoardTemperature',
        CASE GPUHealth
        WHEN "Degraded"  then "Degraded"
        WHEN "OK" then "OK"
        WHEN "Critical" then "Critical"
        WHEN "Unknown" then "Unknown"
        ELSE null
        END as 'Metric-GPUHealth',

        CASE GPUStatus
        WHEN "Available"  then "Available"
        WHEN "Not Applicable" then "Not Applicable"
        WHEN "Unavailable" then "Unavailable"
        ELSE null
        END as 'Metric-GPUStatus',

        MemoryTemp             as 'Metric-MemoryTemperature',
        CASE PowerBrakeState
        WHEN "Not Applicable"  then "Available"
        WHEN "Released" then "Not Applicable"
        WHEN "Set" then "Unavailable"
        ELSE null
        END as 'Metric-PowerBrakeState',

        PowerConsumption       as 'Metric-PowerConsumption',
        CASE PowerSupplyStatus
        WHEN "Disabled"  then "Disabled"
        WHEN "Enabled" then "Enabled"
        WHEN "Not Applicable" then "Not Applicable"
        ELSE null
        END as 'Metric-PowerSupplyStatus',

        PrimaryGpuTemp         as 'Metric-PrimaryTemperature',
        SecondaryGpuTemp       as 'Metric-SecondaryTemperature',
        CASE ThermalAlertState
        WHEN "Not Applicable" then "Not Applicable"
        WHEN "NotPending"     then "NotPending"
        WHEN "Pending"        then "Pending"
        ELSE null
        END as 'Metric-ThermalAlertState'

      FROM TblGPUHealthObj
      WHERE Timestamp > :HWM

  NICPortStats:
    Type: MetricColumns
    # statistictime is the underlying HWM, so we can scan the table slightly more often
    ScanInterval: 0
    WaitInterval: 300
    # CIMVIEW_DCIM_NICStatistics is a VIEW, so do dbchange on the underlying table
    DBChange:
      DMLiveObjectDatabase.db:
        TblNic_Port_Stats_Obj:
        TblNic_Partition_Stats_Obj:
        TblNic_RDMA_Stats_Obj:
        TblSfp_Sensor_Obj:
    Query: |
      SELECT DISTINCT
        TblNic_Port_Stats_Obj.StatisticsTime * 1000000000 as Timestamp,
        TblNic_Port_Stats_Obj.hdr_DOT_fqdd as Context,
         '/redfish/v1/FIXME/' || TblNic_Port_Stats_Obj.hdr_DOT_fqdd as Property,
        TblNic_Port_Stats_Obj.hdr_DOT_fqdd as FQDD,
        'DMLiveObjectDatabase.db::TblNic_Port_Stats_Obj::' || TblNic_Port_Stats_Obj.ROWID as MVSourceTraceInfo,

        -- MEB 2020-02-07 - observed 5s intervals
        30000000000 as 'SensorInterval',  -- 5s interval w/ 1s slack
        5000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        case
           when TblNic_Port_Stats_Obj.TransmitTotalUnicast != -1
              then TblNic_Port_Stats_Obj.TransmitTotalUnicast
        end AS 'Metric-TxUnicast',
        case
           when TblNic_Port_Stats_Obj.TransmitTotalPauseXONFrames != (1<<32)-1
              then TblNic_Port_Stats_Obj.TransmitTotalPauseXONFrames
        end AS 'Metric-TxPauseXONFrames',
        case
           when TblNic_Port_Stats_Obj.TransmitTotalPauseXOFFFrames != (1<<32)-1
              then TblNic_Port_Stats_Obj.TransmitTotalPauseXOFFFrames
        end AS 'Metric-TxPauseXOFFFrames',
        case
           when TblNic_Port_Stats_Obj.TransmitTotalMutlicast != -1
              then TblNic_Port_Stats_Obj.TransmitTotalMutlicast
        end AS 'Metric-TxMutlicast',
        case
           when TblNic_Port_Stats_Obj.TransmitErrorPktSingleCollision != (1<<32)-1
              then TblNic_Port_Stats_Obj.TransmitErrorPktSingleCollision
        end AS 'Metric-TxErrorPktSingleCollision',
        case
           when TblNic_Port_Stats_Obj.TransmitErrorPktMultipleCollision != (1<<32)-1
              then TblNic_Port_Stats_Obj.TransmitErrorPktMultipleCollision
        end AS 'Metric-TxErrorPktMultipleCollision',
        case
           when TblNic_Port_Stats_Obj.TransmitErrorPktLateCollision != (1<<32)-1
              then TblNic_Port_Stats_Obj.TransmitErrorPktLateCollision
        end AS 'Metric-TxErrorPktLateCollision',
        case
           when TblNic_Port_Stats_Obj.TransmitErrorPktExcessiveCollision != (1<<32)-1
              then TblNic_Port_Stats_Obj.TransmitErrorPktExcessiveCollision
        end AS 'Metric-TxErrorPktExcessiveCollision',
        case
           when TblNic_Port_Stats_Obj.TransmitTotalBytes != -1
              then TblNic_Port_Stats_Obj.TransmitTotalBytes
        end AS 'Metric-TxBytes',
        case
           when TblNic_Port_Stats_Obj.TransmitTotalBroadcast != -1
              then TblNic_Port_Stats_Obj.TransmitTotalBroadcast
        end AS 'Metric-TxBroadcast',
        case
           when TblNic_Port_Stats_Obj.ReceiveTotalUnicast != -1
              then TblNic_Port_Stats_Obj.ReceiveTotalUnicast
        end AS 'Metric-RxUnicast',
        case
           when TblNic_Port_Stats_Obj.ReceiveRuntPkt != (1<<32)-1
              then TblNic_Port_Stats_Obj.ReceiveRuntPkt
        end AS 'Metric-RxRuntPkt',
        case
           when TblNic_Port_Stats_Obj.ReceiveTotalPauseXONFrames != (1<<32)-1
              then TblNic_Port_Stats_Obj.ReceiveTotalPauseXONFrames
        end AS 'Metric-RxPauseXONFrames',
        case
           when TblNic_Port_Stats_Obj.ReceiveTotalPauseXOFFFrames != (1<<32)-1
              then TblNic_Port_Stats_Obj.ReceiveTotalPauseXOFFFrames
        end AS 'Metric-RxPauseXOFFFrames',
        case
           when TblNic_Port_Stats_Obj.ReceiveTotalMutlicast != -1
              then TblNic_Port_Stats_Obj.ReceiveTotalMutlicast
        end AS 'Metric-RxMutlicast',
        case
           when TblNic_Port_Stats_Obj.ReceiveJabberPkt != (1<<32)-1
              then TblNic_Port_Stats_Obj.ReceiveJabberPkt
        end AS 'Metric-RxJabberPkt',
        case
           when TblNic_Port_Stats_Obj.ReceiveFalseCarrierDetection != (1<<32)-1
              then TblNic_Port_Stats_Obj.ReceiveFalseCarrierDetection
        end AS 'Metric-RxFalseCarrierDetection',
        case
           when TblNic_Port_Stats_Obj.ReceiveErrorPktFCSErrors != (1<<32)-1
              then TblNic_Port_Stats_Obj.ReceiveErrorPktFCSErrors
        end AS 'Metric-RxErrorPktFCSErrors',
        case
           when TblNic_Port_Stats_Obj.ReceiveErrorPktAlignmentErrors != (1<<32)-1
              then TblNic_Port_Stats_Obj.ReceiveErrorPktAlignmentErrors
        end AS 'Metric-RxErrorPktAlignmentErrors',
        case
           when TblNic_Port_Stats_Obj.ReceiveTotalBytes != -1
              then TblNic_Port_Stats_Obj.ReceiveTotalBytes
        end AS 'Metric-RxBytes',

        case
           when TblNic_Port_Stats_Obj.ReceiveTotalBroadcast != -1
              then TblNic_Port_Stats_Obj.ReceiveTotalBroadcast
        end AS 'Metric-RxBroadcast',
        case TblNic_Port_Stats_Obj.OSDriverState
          when 0 then "Non-operational"
          when 1 then "Operational"
          when 2 then "Unknown"
          else null
        end as 'Metric-OSDriverState',
        case TblNic_Port_Stats_Obj.LinkStatus
          when 0 then "Down"
          when 1 then "Up"
          when 2 then "Unknown"
          else null
        end as 'Metric-LinkStatus',

        case
           when TblNic_Port_Stats_Obj.DiscardedPkts != (1<<32)-1
              then TblNic_Port_Stats_Obj.DiscardedPkts
        end AS 'Metric-DiscardedPkts',

        case
           when TblNic_RDMA_Stats_Obj.RDMATxTotalWritePkts != -1
              then TblNic_RDMA_Stats_Obj.RDMATxTotalWritePkts
        end AS 'Metric-RDMATxTotalWritePkts',
        case
           when TblNic_RDMA_Stats_Obj.RDMATxTotalSendPkts != -1
              then TblNic_RDMA_Stats_Obj.RDMATxTotalSendPkts
        end AS 'Metric-RDMATxTotalSendPkts',
        case
           when TblNic_RDMA_Stats_Obj.RDMATxTotalReadReqPkts != -1
              then TblNic_RDMA_Stats_Obj.RDMATxTotalReadReqPkts
        end AS 'Metric-RDMATxTotalReadReqPkts',
        case
           when TblNic_RDMA_Stats_Obj.RDMATxTotalPackets != -1
              then TblNic_RDMA_Stats_Obj.RDMATxTotalPackets
        end AS 'Metric-RDMATxTotalPackets',
        case
           when TblNic_RDMA_Stats_Obj.RDMATxTotalBytes != -1
              then TblNic_RDMA_Stats_Obj.RDMATxTotalBytes
        end AS 'Metric-RDMATxTotalBytes',
        case
           when TblNic_RDMA_Stats_Obj.TotalProtocolErrors != (1<<32)-1
              then TblNic_RDMA_Stats_Obj.TotalProtocolErrors
        end AS 'Metric-RDMATotalProtocolErrors',
        case
           when TblNic_RDMA_Stats_Obj.TotalProtectionErrors != (1<<32)-1
              then TblNic_RDMA_Stats_Obj.TotalProtectionErrors
        end AS 'Metric-RDMATotalProtectionErrors',
        case
           when TblNic_RDMA_Stats_Obj.RDMARxTotalPackets != -1
              then TblNic_RDMA_Stats_Obj.RDMARxTotalPackets
        end AS 'Metric-RDMARxTotalPackets',
        case
           when TblNic_RDMA_Stats_Obj.RDMARxTotalBytes != -1
              then TblNic_RDMA_Stats_Obj.RDMARxTotalBytes
        end AS 'Metric-RDMARxTotalBytes',

        case TblNic_Partition_Stats_Obj.PartitionOSDriverState
          when 0 then "Non-operational"
          when 1 then "Operational"
          when 2 then "Unknown"
          else null
        end as 'Metric-PartitionOSDriverState',
        case TblNic_Partition_Stats_Obj.PartitionLinkStatus
          when 0 then "Down"
          when 1 then "Up"
          when 2 then "Unknown"
          else null
        end as 'Metric-PartitionLinkStatus',

        case
           when TblNic_Partition_Stats_Obj.LanUnicastPktTXCount != -1
              then TblNic_Partition_Stats_Obj.LanUnicastPktTXCount
        end AS 'Metric-LanUnicastPktTXCount',
        case
           when TblNic_Partition_Stats_Obj.LanUnicastPktRXCount != -1
              then TblNic_Partition_Stats_Obj.LanUnicastPktRXCount
        end AS 'Metric-LanUnicastPktRXCount',
        case
           when TblNic_Partition_Stats_Obj.LanFCSRxErrors != (1<<32)-1
              then TblNic_Partition_Stats_Obj.LanFCSRxErrors
        end AS 'Metric-LanFCSRxErrors',
        case
           when TblNic_Partition_Stats_Obj.FCOERxPktDroppedCount != (1<<32)-1
              then TblNic_Partition_Stats_Obj.FCOERxPktDroppedCount
        end AS 'Metric-FCOERxPktDroppedCount',
        case
           when TblNic_Partition_Stats_Obj.FCOEPktTxCount != -1
              then TblNic_Partition_Stats_Obj.FCOEPktTxCount
        end AS 'Metric-FCOEPktTxCount',
        case
           when TblNic_Partition_Stats_Obj.FCOEPktRxCount != -1
              then TblNic_Partition_Stats_Obj.FCOEPktRxCount
        end AS 'Metric-FCOEPktRxCount',
        case
           when TblNic_Partition_Stats_Obj.FCOELinkFailures != (1<<32)-1
              then TblNic_Partition_Stats_Obj.FCOELinkFailures
        end AS 'Metric-FCOELinkFailures',
        case
           when TblNic_Partition_Stats_Obj.FCCRCErrorCount != (1<<32)-1
              then TblNic_Partition_Stats_Obj.FCCRCErrorCount
        end AS 'Metric-FCCRCErrorCount'

        -- These are somewhat interesting in the underlying table (TblSfp_Sensor_Obj). Need to see
        -- if we can output these as well
        -- Temperature as 'Metric-TemperatureReading'
        -- VoltageValue as 'Metric-VoltageReading'
        --'RXInputPower'
        --'RXInputPowerStatus'
        --'TXBiasCurrent'
        --'TXBiasCurrentStatus'
        --'TXOutputPower'
        --'TXOutputPowerStatus'

      FROM TblNic_Port_Stats_Obj
      left join TblNic_Partition_Stats_Obj
        on (instr(TblNic_Partition_Stats_Obj.hdr_DOT_key,TblNic_Port_Stats_Obj.hdr_DOT_fqdd) > 0)
      left join TblNic_RDMA_Stats_Obj
        on (instr(TblNic_RDMA_Stats_Obj.hdr_DOT_key,TblNic_Port_Stats_Obj.hdr_DOT_fqdd) > 0)
      WHERE ((select ActiveOIDMapping.ObjType from ActiveOIDMapping
        where TblNic_Port_Stats_Obj.OID = ActiveOIDMapping.OID ) = 1809) --NIC_PORT_STATS_OBJ(0x711)
      AND Timestamp > :HWM

  HIITempSensors:
    Type: MetricColumns
    ScanInterval: 0
    WaitInterval: 1
    DBChange:
      DMLiveObjectDatabase.db:
        TblHIISensorInfo_obj:
    Query: |
      SELECT
        SingleRecordEtag * 1000000000 as Timestamp,
        FriendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',
        'DMLiveObjectDatabase.db::TblHIISensorInfo_obj::' || ROWID as MVSourceTraceInfo,

        currentTemp as 'Metric-TemperatureReading'
      FROM TblHIISensorInfo_obj
      WHERE Timestamp > :HWM

  Fan:
    Type: MetricColumns
    ScanInterval: 0
    WaitInterval: 1
    DBChange:
      DMLiveObjectDatabase.db:
        TblFanExtObj:
    Query: |
      SELECT
        UpdateTime * 1000000000 as Timestamp,
        FriendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        'DMLiveObjectDatabase.db::TblFanExtObj::' || ROWID as MVSourceTraceInfo,

        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        VariableSpeed as 'Metric-RPMReading'
      from TblFanExtObj
      WHERE Timestamp > :HWM

  RAWSensor:
    Type: DirectMetric
    ScanInterval: 0
    WaitInterval: 5
    DBChange:
      DMLiveObjectDatabase.db:
        TblProbeObj:
    Query: |
      SELECT
        SingleRecordEtag * 1000000000 as Timestamp,
        ProbeLocation as Context,

        Key as FQDD,
        ProbeLocation as FriendlyFQDD,
        5000000000 as 'MVSensorInterval',
        1000000000 as 'MVSensorSlack',
        true as 'MVRequiresExpand',

        -- property not quite right, as PS sensors are an exception
        printf('/redfish/v1/Dell/Systems/System.Embedded.1/DellNumericSensor/%s', replace(replace(Key, '|', '_0x7c_') , '#', '_0x23_')) as Property,
        'DMLiveObjectDatabase.db::TblProbeObj::' || TblProbeObj.ROWID as MVSourceTraceInfo,

        CASE ObjType
        WHEN 0x16 then 'TemperatureReading'
        WHEN 0x17 then 'RPMReading'
        WHEN 0x18 then 'VoltageReading'
        WHEN 0x19 then
          CASE subtype
            WHEN 0x17 THEN 'AmpsReading'
            WHEN 0x19 THEN 'WattsReading'
            WHEN 0x18 THEN 'AmpsReading'
            WHEN 0x1a THEN 'WattsReading'
          END
        WHEN 56 then
          CASE key
          WHEN 'iDRAC.Embedded.1#SystemBoardCPUUsage' then 'CPUUsage'
          WHEN 'iDRAC.Embedded.1#SystemBoardSYSUsage' then 'SystemUsage'
          WHEN 'iDRAC.Embedded.1#SystemBoardMEMUsage' then 'MemoryUsage'
          WHEN 'iDRAC.Embedded.1#SystemBoardIOUsage'  then 'IOUsage'
          END
        ELSE 'IGNORE'
        END as Name,

        -- manually expand x^y since sqlite is missing a pow() or exp() function
        CASE UnitModifier
        WHEN -6 THEN ProbeReading * 1000000.0
        WHEN -5 THEN ProbeReading * 100000.0
        WHEN -4 THEN ProbeReading * 10000.0
        WHEN -3 THEN ProbeReading * 1000.0
        WHEN -2 THEN ProbeReading * 100.0
        WHEN -1 THEN ProbeReading * 10.0
        WHEN  0 THEN ProbeReading * 1.0
        WHEN  1 THEN ProbeReading / 10.0
        WHEN  2 THEN ProbeReading / 100.0
        WHEN  3 THEN ProbeReading / 1000.0
        WHEN  4 THEN ProbeReading / 10000.0
        WHEN  5 THEN ProbeReading / 100000.0
        WHEN  6 THEN ProbeReading / 1000000.0
        END as Value

      FROM TblProbeObj
      left join
        ActiveOIDMapping on TblProbeObj.OID = ActiveOIDMapping.OID
      WHERE
        Timestamp > :HWM AND
        Name != 'IGNORE'

internal:
  # we can put the sql statements that we use internally in metric engine here
  # two benefits:
  #   - reduced binary size: we get rid of the sql string from the process memory space
  #   - increased performance: get rid of the internal prepares that are done by the database driver, especially helps in inner loops
  #
  # Be aware: Viper will lower case all names of config keys, so just them here as lower case or people might get confused.
  #
  namedsql:
    md_insert: |
      INSERT INTO MetricDefinition
               ( MetricId, Name, Description, MetricType, MetricDataType, Units, Accuracy, SensingInterval, DiscreteValues)
        VALUES (:MetricID, :Name, :Description, :MetricType, :MetricDataType, :Units, :Accuracy, :SensingInterval, :DiscreteValues)

    mrd_insert: |
      INSERT INTO MetricReportDefinition
               ( Name,  ShortDesc,  LongDesc,  Enabled,  AppendLimit,  Type,  SuppressDups,  Actions,  Updates,  Period,  TimeSpan,  Hidden)
        VALUES (:Name, :ShortDesc, :LongDesc, :Enabled, :AppendLimit, :Type, :SuppressDups, :Actions, :Updates, :Period, :TimeSpan, :Hidden)

    trg_insert: |
      INSERT INTO Trigger
               ( RedfishID, Name, Description, MetricType, TriggerActions)
        VALUES (:RedfishID, :Name, :Description, :MetricType, :TriggerActions)

    evttrg_insert: |
      INSERT INTO EventTriggers
               ( EemiID, TriggerID)
        VALUES (:EemiID, :TriggerID)

    trgmrd_insert: |
      INSERT INTO TriggerToMRD
               ( MetricReportDefinitionID, TriggerID)
        VALUES (:MetricReportDefinitionID, :TriggerID)

    trg_update: |
      UPDATE Trigger
      SET
        Name=:Name,
        Description=:Description,
        MetricType=:MetricType,
        TriggerActions=:TriggerActions
      WHERE RedfishID=:RedfishID

    mrd_update: |
      UPDATE MetricReportDefinition
      SET
        ShortDesc=:ShortDesc,
        LongDesc=:LongDesc,
        Enabled=:Enabled,
        AppendLimit=:AppendLimit,
        Type=:Type,
        SuppressDups=:SuppressDups,
        Actions=:Actions,
        Period=:Period,
        Updates=:Updates,
        TimeSpan=:TimeSpan,
        Hidden=:Hidden
      WHERE
        Name=:Name

    find_mm: |
      select ID from MetricMeta where
        NamePattern=:NamePattern and
        SuppressDups=:SuppressDups and
        FQDDPattern=:FQDDPattern and
        SourcePattern=:SourcePattern and
        PropertyPattern=:PropertyPattern and
        Wildcards=:Wildcards and
        CollectionFunction=:CollectionFunction and
        CollectionDuration=:CollectionDuration

    insert_mm: |
      INSERT INTO MetricMeta
             ( NamePattern,  SuppressDups,  FQDDPattern,  SourcePattern,  PropertyPattern,  Wildcards,  CollectionFunction,  CollectionDuration)
      VALUES (:NamePattern, :SuppressDups, :FQDDPattern, :SourcePattern, :PropertyPattern, :Wildcards, :CollectionFunction, :CollectionDuration)

    delete_mr_by_id: delete from MetricReport where ReportDefinitionID=:MRDID

    insert_report: |
      -- TODO Need to also max the value from the starttimestamp with the passed in start value
      INSERT INTO MetricReport
              (Name, ReportDefinitionID, ReportTimestamp, Sequence, StartTimestamp)
      VALUES (
        :Name, :MRDID, :ReportTimestamp,
        IFNULL((SELECT MAX(sequence)+1 FROM MetricReport WHERE ReportDefinitionID=:MRDID), 0),
        IFNULL((SELECT MAX(ReportTimestamp) FROM MetricReport WHERE ReportDefinitionID=:MRDID), :Start)
        );

    keep_only_3_reports: |
      -- Ensure there are max 3 reports (NO-OP except for Type=NewReport... thats ok)
      DELETE FROM MetricReport
      WHERE Name IN (
        SELECT name FROM (
          SELECT
            MR.name AS Name,
            MR.ReportDefinitionID,
            MR.sequence AS Seq,
            MAX(MR2.Sequence) AS MS
          FROM MetricReport AS MR
          LEFT JOIN MetricReport AS MR2
          ON MR.ReportDefinitionID = MR2.ReportDefinitionID
          GROUP BY MR.Name
        )
        WHERE seq+2<MS
      );

    update_report_set_start_to_prev_timestamp: |
      UPDATE MetricReport
      SET StartTimestamp = ReportTimestamp
      WHERE Name = :Name

    update_report_ts_seq: |
      UPDATE MetricReport
      SET ReportTimestamp = :ReportTimestamp,
          Sequence = Sequence + 1
      WHERE Name = :Name

    update_report_start: |
      UPDATE MetricReport
      SET StartTimestamp = :Start
      WHERE Name = :Name

    find_metric_meta: |
      SELECT
        ID AS MetaID, FQDDPattern, SourcePattern, PropertyPattern, Wildcards, CollectionFunction, CollectionDuration, SuppressDups
      FROM MetricMeta
      WHERE
        (NamePattern     = '' OR :Name     LIKE NamePattern)     AND
        (FQDDPattern     = '' OR :FQDD     LIKE FQDDPattern)     AND
        (SourcePattern   = '' OR :Source   LIKE SourcePattern)   AND
        (PropertyPattern = '' OR :Property LIKE PropertyPattern)

    insert_metric_instance: |
      INSERT INTO MetricInstance
             ( Name,  FQDD,  Property,  Context,  Function,                      Duration,  Label,  CollectionScratch, LastValue, LastTS,  FlushTime,  SuppressDups, Dirty,    RequiresExpand,    SensorInterval,    SensorSlack,  Source,  SourceTraceInfo)
      VALUES (:Name, :FQDD, :Property, :Context, :CollectionFunction, :CollectionDuration, :Label, :CollectionScratch, '',        0,      :FlushTime, :SuppressDups, false, :MVRequiresExpand, :MVSensorInterval, :MVSensorSlack, :Source, :MVSourceTraceInfo)

    find_metric_instance: |
      select
        MI.ID as InstanceID,
        MI.Dirty as Dirty,
        MI.Source as Source,
        MI.Name as Name,
        (select count(*) from MetricMetaToInstance as MMTI where MMTI.InstanceID = MI.ID and MMTI.MetaID = :MetaID) as HasAssocMM
      from MetricInstance as MI
      where
        MI.Name=:Name and
        MI.FQDD=:FQDD and
        MI.Property=:Property and
        MI.Context=:Context and
        MI.Function=:CollectionFunction and
        MI.Duration=:CollectionDuration

    set_metric_instance_dirty: |
      UPDATE MetricInstance set Dirty=true

    set_metric_instance_clean: |
      UPDATE MetricInstance set Dirty=false, RequiresExpand=:MVRequiresExpand where ID=:InstanceID

    iterate_metric_instance: |
      select distinct
        MI.ID as InstanceID,
        MI.CollectionScratch,
        MI.LastTS,
        MI.LastValue,
        MI.FlushTime,
        MI.SuppressDups,
        MI.Function as CollectionFunction,
        MI.Duration as CollectionDuration,
        MI.Dirty,
        MI.RequiresExpand as MIRequiresExpand,
        MI.SensorInterval as MISensorInterval,
        MI.SensorSlack    as MISensorSlack,
        MI.SourceTraceInfo as MISourceTraceInfo
      from MetricInstance as MI
      where
        MI.Name=:Name and
        MI.FQDD=:FQDD and
        MI.Property=:Property and
        MI.Context=:Context

    iterate_metric_instance_for_report: |
      select distinct
        MI.ID as InstanceID,
        MI.Source as Source,
        MI.Name as Name,
        MI.CollectionScratch,
        MI.LastTS,
        MI.LastValue,
        MI.FlushTime,
        MI.SuppressDups,
        MI.Function as CollectionFunction,
        MI.Duration as CollectionDuration,
        MI.Dirty,
        MI.RequiresExpand as MIRequiresExpand,
        MI.SensorInterval as MISensorInterval,
        MI.SensorSlack    as MISensorSlack,
        MI.SourceTraceInfo as MISourceTraceInfo
      from MetricInstance as MI
      inner join MetricMetaToInstance as MMTI on MI.ID = MMTI.InstanceID
      inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
      where
        rd2mm.ReportDefinitionID = :ID


    update_metric_instance: |
      UPDATE MetricInstance
      SET LastTS=:LastTS, LastValue=:LastValue, CollectionScratch=:CollectionScratch, FlushTime=:FlushTime
      WHERE ID=:InstanceID

    count_report_records: |
        select
          count(*) as Count
        from MetricValue as MV
        inner join MetricMetaToInstance as MMTI on MV.InstanceID = MMTI.InstanceID
        inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
        WHERE
          ( rd2mm.ReportDefinitionID = :MRDID ) AND
          ( MV.Timestamp > :Start )


  sqlx:
    find_onchange_mrd_by_mm_instance: |
      select
        MRD.Name
      from MetricReportDefinition as MRD
      inner join ReportDefinitionToMetricMeta as rd2mm on MRD.ID = rd2mm.ReportDefinitionID
      inner join MetricMetaToInstance as MMTI on rd2mm.MetaID = MMTI.MetaID
      where MRD.Type = "OnChange" and MMTI.InstanceID = ?

    mrd_select_idbyname: SELECT ID FROM MetricReportDefinition where Name=?

    generic_get: select root from JSON where [@odata.id] = ?

    delete_mrd: delete from MetricReportDefinition where name=?
    delete_mr: delete from MetricReport where Name=?

    delete_mm_assoc: delete from ReportDefinitionToMetricMeta where ReportDefinitionID=?

    insert_mm_assoc: INSERT INTO ReportDefinitionToMetricMeta (ReportDefinitionID, MetaID) VALUES (?, ?)
    insert_mi_assoc: INSERT INTO MetricMetaToInstance (MetaID, InstanceID) VALUES (?, ?)

    query_mrds: SELECT ID, Name,  Enabled, AppendLimit, Type, SuppressDups, Actions, Updates FROM MetricReportDefinition

    delete_mvi: delete from MetricValueInt where Timestamp > (select Timestamp from MetricValueInt order by Timestamp Limit 1 Offset 100000)
    delete_mvr: delete from MetricValueReal where Timestamp > (select Timestamp from MetricValueReal order by Timestamp Limit 1 Offset 100000)
    delete_mvt: delete from MetricValueText where Timestamp > (select Timestamp from MetricValueText order by Timestamp Limit 1 Offset 50000)
    delete_old_mr: |
      --// Only should have max 3 "new" reports per Metric Report Definition
      -- somewhat complicated query, but not too bad...
      DELETE FROM MetricReport WHERE Name IN (
        SELECT
          Name
        FROM (
          SELECT
            MR.name AS Name,
            MR.ReportDefinitionID,
            MR.sequence AS Seq,
            MAX(MR2.Sequence) AS MS
          FROM
            MetricReport AS MR
          LEFT JOIN
            MetricReport AS MR2 ON MR.ReportDefinitionID = MR2.ReportDefinitionID
          GROUP BY
            MR.Name
        )
        WHERE Seq+2<MS
      )

    delete_old_mvi: |
      delete from MetricValueInt where (InstanceID, Timestamp) IN
      (
        select MVI.InstanceID, MVI.TimeStamp
        from MetricValueInt as MVI
        left join OldestMetricInstanceInReportInt as MITR on MVI.InstanceID = MITR.InstanceID
        where MVI.Timestamp < MITR.MinTS
      );
    delete_old_mvr: |
      delete from MetricValueReal where (InstanceID, Timestamp) IN
      (
        select MVR.InstanceID, MVR.TimeStamp
        from MetricValueReal as MVR
        left join OldestMetricInstanceInReportReal as MITR on MVR.InstanceID = MITR.InstanceID
        where MVR.Timestamp < MITR.MinTS
      );
    delete_old_mvt: |
      delete from MetricValueText where (InstanceID, Timestamp) IN
      (
        select MVT.InstanceID, MVT.TimeStamp
        from MetricValueText as MVT
        left join OldestMetricInstanceInReportText as MITR on MVT.InstanceID = MITR.InstanceID
        where MVT.Timestamp < MITR.MinTS
      );


    # delete orphans of all kinds.
    #   Metric Report Definitions (MRD) are the source of truth
    #    .. Delete any ReportDefinitionToMetricMeta that doesn't match an MRD
    #    .. Delete any ReportDefinitionToMetricMeta that doesn't match a MetricMeta
    #    XX Delete any MetricMeta that doesnt have a ReportDefinitionToMetricMeta entry
    #    XX Delete any MetricInstance that doesnt have a MetricMetaToInstance entry
    #    .. Delete any MetricValue without MetricInstance
    #
    # XX = complete
    # .. = Should be covered by foreign key cascade delete
    # oo = Should be covered by foreign key cascade delete, but double check
    delete_orphan_metricmeta: |
      DELETE FROM MetricMeta WHERE id IN
      (
        select mm.ID from MetricMeta as mm
          LEFT JOIN ReportDefinitionToMetricMeta as rd2mm on mm.ID = rd2mm.MetaID where rd2mm.MetaID is null
      )

    delete_orphan_metricinstance: |
      DELETE FROM MetricInstance WHERE id IN
      (
        select MI.ID as InstanceID from MetricInstance as MI
          LEFT JOIN MetricMetaToInstance as MMTI on MMTI.InstanceID = MI.ID where MMTI.InstanceID is null
      )

    find_mrd_by_id: |
      SELECT
        ID,
        Name,
        ShortDesc,
        LongDesc,
        Enabled,
        AppendLimit,
        Type,
        SuppressDups,
        Actions,
        Updates,
        Period,
        TimeSpan,
        HeartbeatInterval,
        Hidden
      FROM MetricReportDefinition where ID=?


    find_mrd_by_name: |
      SELECT
        ID,
        Name,
        ShortDesc,
        LongDesc,
        Enabled,
        AppendLimit,
        Type,
        SuppressDups,
        Actions,
        Updates,
        Period,
        TimeSpan,
        HeartbeatInterval,
        Hidden
      FROM MetricReportDefinition where Name=?

    trglist_by_mrdid: |
      SELECT
        group_concat(RedfishID, " ")
        FROM Trigger, TriggerToMRD
        WHERE Trigger.ID = TriggerID AND MetricReportDefinitionID = ?

    find_trg_by_name: |
      SELECT
        ID,
        RedfishID,
        Name,
        Description,
        MetricType,
        TriggerActions
      FROM Trigger WHERE RedfishID=?

    find_trg_by_id: |
      SELECT
        ID,
        RedfishID,
        Name,
        Description,
        MetricType,
        TriggerActions
      FROM Trigger WHERE ID=?

    trgmrd_del_assoc: |
      DELETE FROM TriggerToMRD
      WHERE TriggerID=?

    mrdtrg_del_assoc: |
      DELETE FROM TriggerToMRD
      WHERE MetricReportDefinitionID=?

    evttrg_del_assoc: |
      DELETE FROM EventTriggers
      WHERE TriggerID=?

    delete_trigger: |
      DELETE FROM Trigger
      WHERE RedfishID=?

    insert_mv_int:  INSERT INTO MetricValueInt  (InstanceID, Timestamp, Value) VALUES (?, ?, ?)
    insert_mv_real: INSERT INTO MetricValueReal (InstanceID, Timestamp, Value) VALUES (?, ?, ?)
    insert_mv_text: INSERT INTO MetricValueText (InstanceID, Timestamp, Value) VALUES (?, ?, ?)
    optimize: pragma optimize
    shrink: pragma shrink_memory
    vacuum: vacuum

createdb:
  #- "PRAGMA busy_timeout = 1000;"
  - "PRAGMA foreign_keys = ON;"
  - "PRAGMA journal_mode = WAL;"
  - "PRAGMA journal_size_limit=512;"   # N * page_size
  - "PRAGMA wal_autocheckpoint = 32;"  # N * page_size
  - "PRAGMA synchronous = NORMAL;"
  # seems to have a great memory consumption benefit:
  - "PRAGMA mmap_size=262144;"         # N bytes - Not "wasting any ram here as it's all in tmpfs already
  - "PRAGMA main.max_page_count = 2560"  # enforce upper limit of 10MB on DB
  - "PRAGMA cache=shared;"
  - "PRAGMA cache_size=-64;"   # -N -> N kilobytes. Default without '-' means "Pages"

  - |
      CREATE TABLE IF NOT EXISTS MetricReportDefinition
      (
        ID                INTEGER PRIMARY KEY NOT NULL,
        Name              TEXT UNIQUE NOT NULL, -- Name of the metric report defintion. This is what shows up in the collection
        ShortDesc         TEXT not null default '',
        LongDesc          TEXT not null default '',
        Enabled           BOOLEAN not null default false,
        AppendLimit       INTEGER not null default 24000,
        Type              TEXT not null default 'OnRequest',           -- type of report: 'Periodic', 'OnChange', 'OnRequest'
        SuppressDups      BOOLEAN not null default true,
        Actions           TEXT not null default '[]',                  -- json array of options: 'LogToMetricReportsCollection', 'RedfishEvent'
        Updates           TEXT not null default 'AppendWrapsWhenFull', -- 'AppendStopsWhenFull', 'AppendWrapsWhenFull', 'NewReport', 'Overwrite'
        Period            INTEGER not null default 0,
        TimeSpan          INTEGER not null default 0,
        HeartbeatInterval INTEGER NOT NULL DEFAULT 0,
        Hidden            BOOLEAN NOT NULL DEFAULT FALSE -- Not displayed to the user, only for internal use
      )

  - |
      -- These always exist
      -- They are created when the report is created
      -- multiple reports can link to the same MetricMeta (many to many relationship)
      CREATE TABLE IF NOT EXISTS MetricMeta
      (
        ID                 INTEGER UNIQUE PRIMARY KEY NOT NULL,
        SuppressDups       BOOLEAN NOT NULL DEFAULT true,
        NamePattern        TEXT NOT NULL DEFAULT "",
        FQDDPattern        TEXT NOT NULL DEFAULT "",   -- Dell OEM extension to sort based on FQDD patterns
        SourcePattern      TEXT NOT NULL DEFAULT "",   -- Dell OEM extension to sort based on where we got the data from
        PropertyPattern    TEXT NOT NULL DEFAULT "",   -- /redfish/v1/some/uri/{with}/{wildcards}#Property
        Wildcards          TEXT NOT NULL DEFAULT "",   --{'wildcard': ['array','of', 'possible', 'replacements'], 'with': ['another', 'list', 'of', 'replacements']}
        CollectionFunction TEXT not null DEFAULT "",   -- 'sum', 'avg', 'min', 'max'
        CollectionDuration INTEGER NOT NULL DEFAULT 0,

        -- indexes and constraints
        unique (NamePattern, FQDDPattern, SourcePattern, PropertyPattern, SuppressDups, Wildcards, CollectionFunction, CollectionDuration)
      )

  - |
      CREATE TABLE IF NOT EXISTS ReportDefinitionToMetricMeta
        (
          ReportDefinitionID   integer not null,
          MetaID               integer not null,

          -- indexes and constraints
          primary key (ReportDefinitionID, MetaID)
          foreign key (ReportDefinitionID)
            references MetricReportDefinition (ID)
              on delete cascade
          foreign key (MetaID)
            references MetricMeta (ID)
              on delete cascade
        );
        CREATE INDEX IF NOT EXISTS report_definition_2_metric_meta_id_idx ON ReportDefinitionToMetricMeta(MetaID)

  - |
      CREATE TABLE IF NOT EXISTS MetricInstance
      (
        ID                INTEGER NOT NULL PRIMARY KEY,
        Name              TEXT    NOT NULL, -- actual metric name
        FQDD              TEXT    NOT NULL,
        Property          TEXT    NOT NULL, -- URI#Property
        Source            TEXT    NOT NULL DEFAULT '',
        Context           TEXT    NOT NULL, -- usually FQDD
        Function          TEXT    NOT NULL,
        Duration          INTEGER NOT NULL DEFAULT 0,
        Label             TEXT    NOT NULL, -- 'friendly FQDD' + 'metric name' + 'collectionfn'
        SuppressDups      BOOLEAN NOT NULL default true,
        CollectionScratch TEXT    NOT NULL, -- Scratch space used by calculation functions
        FlushTime         INTEGER,          -- Time at which any aggregated data should be flushed
        LastTS            INTEGER NOT NULL, -- Used to quickly suppress dups for this instance
        LastValue         TEXT    NOT NULL, -- Used to quickly suppress dups for this instance
        RequiresExpand    BOOLEAN NOT NULL DEFAULT TRUE, -- should we automatically expand gaps
        SensorInterval    INTEGER NOT NULL DEFAULT 0,    -- set to the backend interval
        SensorSlack       INTEGER NOT NULL DEFAULT 0,    -- how much subsequent timestamps can drift
        SourceTraceInfo   TEXT    NOT NULL DEFAULT '',   -- DB:TABLE:ROWID -- can look for sqlite operation==(delete) and turn off sensor interval
        Dirty             BOOLEAN NOT NULL DEFAULT TRUE, -- set to dirty any time MRD changes, clean once a metric has been processed

        -- indexes and constraints
        unique (Name, FQDD, Property, Context, Function, Duration, SuppressDups)
      )

  - |
      CREATE TABLE IF NOT EXISTS MetricMetaToInstance
      (
        MetaID      integer not null,
        InstanceID  integer not null,

        -- indexes and constraints
        primary key (InstanceID, MetaID)
        foreign key (InstanceID)
          references MetricInstance (ID)
            on delete cascade
        foreign key (MetaID)
          references MetricMeta (ID)
            on delete cascade
      );
      CREATE INDEX IF NOT EXISTS metric_meta_to_instance_metaid_idx ON MetricMetaToInstance(InstanceID)

  - |
      CREATE TABLE IF NOT EXISTS MetricValueInt
      (
        InstanceID INTEGER NOT NULL,
        Timestamp  INTEGER NOT NULL,
        Value      INTEGER NOT NULL,

        -- indexes and constraints
        PRIMARY KEY (InstanceID, Timestamp),
        FOREIGN KEY (InstanceID)
          REFERENCES MetricInstance (ID) ON DELETE CASCADE
      ) WITHOUT ROWID;

  - |
      CREATE TABLE IF NOT EXISTS MetricValueReal
      (
        InstanceID INTEGER NOT NULL,
        Timestamp  INTEGER NOT NULL,
        Value      REAL    NOT NULL,

        -- indexes and constraints
        PRIMARY KEY (InstanceID, Timestamp),
        FOREIGN KEY (InstanceID)
          REFERENCES MetricInstance (ID) ON DELETE CASCADE
      ) WITHOUT ROWID;

  - |
      CREATE TABLE IF NOT EXISTS MetricValueText
      (
        InstanceID INTEGER NOT NULL,
        Timestamp  INTEGER NOT NULL,
        Value      TEXT    NOT NULL,

        -- indexes and constraints
        PRIMARY KEY (InstanceID, Timestamp),
        FOREIGN KEY (InstanceID)
          REFERENCES MetricInstance (ID) ON DELETE CASCADE
      ) WITHOUT ROWID;

  - |
      CREATE View IF NOT EXISTS MetricValue as
        -- order is important here. dont re-arrange these, or you will break things
        select InstanceID, Timestamp, Value from MetricValueText
        union all
        select InstanceID, Timestamp, Value from MetricValueInt
        union all
        select InstanceID, Timestamp, Value from MetricValueReal;

  - |
      CREATE INDEX IF NOT EXISTS metric_value_int_ts_xref_idx on MetricValueInt(Timestamp);
      CREATE INDEX IF NOT EXISTS metric_value_real_ts_xref_idx on MetricValueReal(Timestamp);
      CREATE INDEX IF NOT EXISTS metric_value_text_ts_xref_idx on MetricValueText(Timestamp);

  - |
      CREATE TABLE IF NOT EXISTS MetricReport
      (
        Name               TEXT PRIMARY KEY UNIQUE NOT NULL,
        ReportDefinitionID INTEGER NOT NULL,
        Sequence           INTEGER NOT NULL DEFAULT 0,
        StartTimestamp     INTEGER NOT NULL DEFAULT (strftime('%s', 'now') * 1000000000),
        ReportTimestamp    INTEGER NOT NULL DEFAULT (strftime('%s', 'now') * 1000000000),

        -- indexes and constraints
        FOREIGN KEY (ReportDefinitionID)
          REFERENCES MetricReportDefinition (ID) ON DELETE CASCADE
      );
      CREATE INDEX IF NOT EXISTS metric_report_xref_idx on MetricReport(ReportDefinitionID);

  - |
      -- all queries to display to the user should use this one, as timestamp fields are 'correct'
      DROP VIEW IF EXISTS MetricReport_calculated;;
      CREATE VIEW IF NOT EXISTS MetricReport_calculated as
        SELECT
          MR.Name as Name,
          MR.ReportDefinitionID,
          MR.Sequence,

          CASE MRD.Type
          WHEN 'Periodic' THEN MR.ReportTimestamp
          WHEN 'OnChange' THEN MR.ReportTimestamp
          WHEN 'OnRequest' THEN cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer)
          ELSE 0
          END as ReportTimestamp,

          CASE MRD.Type
          WHEN 'Periodic' THEN
            CASE
            WHEN MRD.TimeSpan = 0 THEN MR.StartTimestamp
            WHEN MR.ReportTimestamp - MRD.TimeSpan < MR.StartTimestamp THEN  MR.ReportTimestamp - MRD.TimeSpan
            ELSE StartTimestamp
            END
          WHEN 'OnChange' THEN ReportTimestamp - MRD.TimeSpan
          WHEN 'OnRequest' THEN cast( (julianday('now') - 2440587.5)*86400 * 1000000000 - MRD.TimeSpan as integer)
          ELSE 0
          END as StartTimestamp

        FROM MetricReport as MR
        INNER JOIN MetricReportDefinition as MRD on MRD.ID = MR.ReportDefinitionID

  - |
      -- TODO: check scalability of this view (should be scalable)
      -- This doesnt have ORDER BY or LIMIT, so it wont by itself limit output, but that also means it will stream.
      DROP VIEW IF EXISTS MetricValueByReport;
      CREATE VIEW MetricValueByReport as
        select
          MR.Name as Name,
          MV.InstanceID,
          MV.Timestamp,
          json_object(
              'MetricId', MI.Name,
              'Timestamp', strftime('%Y-%m-%dT%H:%M:%fZ', MV.Timestamp/1000000000, 'unixepoch'),
              'MetricValue', MV.Value,
              'OEM', json_object(
                'Dell', json_object(
                  'ContextID', MI.Context,
                  'Label', MI.Label,
                  'Source', MI.Source,
                  'FQDD', MI.FQDD
                )
          )) as 'JSON'
        from MetricReport_calculated as MR
        inner join ReportDefinitionToMetricMeta as rd2mm on MR.ReportDefinitionID = rd2mm.ReportDefinitionID
        inner join MetricMetaToInstance as MMTI on rd2mm.MetaID = MMTI.MetaID
        inner join MetricInstance as MI on MMTI.InstanceID = MI.ID
        inner join MetricValue as MV on MI.ID = MV.InstanceID
        WHERE
          ( MV.Timestamp > MR.StartTimestamp ) AND
          ( MV.Timestamp <= MR.ReportTimestamp )

  - |
      -- TODO: check scalability of this view (PROBABLY DOESNT SCALE DUE TO GROUP BY)
      DROP VIEW IF EXISTS OldestMetricInstanceInReportInt;
      CREATE VIEW OldestMetricInstanceInReportInt as
        select
          MV.InstanceID as InstanceID,
          min(mv.timestamp) as MinTS
        from MetricValueInt as MV
        inner join MetricMetaToInstance as MMTI on MV.InstanceID = MMTI.InstanceID
        inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
        inner join MetricReport_calculated as MR on MR.ReportDefinitionID = rd2mm.ReportDefinitionID
        WHERE MV.Timestamp > MR.StartTimestamp
        group by MV.InstanceID

  - |
      -- TODO: check scalability of this view (PROBABLY DOESNT SCALE DUE TO GROUP BY)
      DROP VIEW IF EXISTS OldestMetricInstanceInReportReal;
      CREATE VIEW OldestMetricInstanceInReportReal as
        select
          MV.InstanceID as InstanceID,
          min(mv.timestamp) as MinTS
        from MetricValueReal as MV
        inner join MetricMetaToInstance as MMTI on MV.InstanceID = MMTI.InstanceID
        inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
        inner join MetricReport_calculated as MR on MR.ReportDefinitionID = rd2mm.ReportDefinitionID
        WHERE MV.Timestamp > MR.StartTimestamp
        group by MV.InstanceID

  - |
      -- TODO: check scalability of this view
      DROP VIEW IF EXISTS OldestMetricInstanceInReportText;
      CREATE VIEW OldestMetricInstanceInReportText as
        select
          MV.InstanceID as InstanceID,
          min(mv.timestamp) as MinTS
        from MetricValueText as MV
        inner join MetricMetaToInstance as MMTI on MV.InstanceID = MMTI.InstanceID
        inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
        inner join MetricReport_calculated as MR on MR.ReportDefinitionID = rd2mm.ReportDefinitionID
        WHERE MV.Timestamp > MR.StartTimestamp
        group by MV.InstanceID

  - |
      -- DOES NOT SCALE:  This uses a temp table to spool the metric values. memory usage scales with # of records output.
      DROP VIEW IF EXISTS MetricReport_JSON;
      DROP VIEW IF EXISTS MetricReport_JSON;
      CREATE VIEW MetricReport_JSON as
      select
        ('{' ||
            ' "@odata.type": "#MetricReport.v1_2_0.MetricReport",' ||
            ' "@odata.context": "/redfish/v1/$metadata#MetricReport.MetricReport",' ||
            ' "@odata.id": "/redfish/v1/TelemetryService/MetricReports/' || MR.Name || '",' ||
            ' "Id": "' || MR.Name || '",' ||
            ' "Name": "' || MR.Name || ' Metric Report",' ||
            CASE MRD.Type
            WHEN 'Periodic' THEN ' "ReportSequence": ' || json_quote(Sequence) || ','
            WHEN 'OnChange' THEN ' "ReportSequence": ' || json_quote(Sequence) || ','
            ELSE ''
            END ||
            ' "Timestamp": ' || strftime('"%Y-%m-%dT%H:%M:%fZ"', MR.ReportTimestamp/1000000000, 'unixepoch') || ', ' ||
            ' "MetricReportDefinition": {"@odata.id": "/redfish/v1/TelemetryService/MetricReportDefinitions/' || MRD.Name || '"}, ' ||
              ifnull((
                SELECT
                  ' "MetricValues":  [' ||  group_concat(a.JSON) || '], ' ||
                  ' "MetricValues@odata.count": ' ||  count(*)
                FROM
                (
                  select JSON
                  from MetricValueByReport as MVR
                  where MVR.Name=MR.Name
                    order by MVR.Timestamp DESC
                    limit 24000
                  ) AS a ),  ' "MetricValues":  [], "MetricValues@odata.count":  0 ')
          || '}'
        ) as root,
        '/redfish/v1/TelemetryService/MetricReports/' || MR.Name as '@odata.id',
        Hidden as Hidden
      from MetricReport_calculated as MR
      inner join MetricReportDefinition as MRD on MRD.ID = MR.ReportDefinitionID

  - |
      -- DOES NOT SCALE:  This uses a temp table to spool the metric values. memory usage scales with # of records output.
      -- do not expect to have scaling issues with this table as we will
      -- generally have a low number of metric reports. just something to be aware
      -- of. Hopefully we can fix the design in the future to be more scalable
      -- (ie. not use sqlite to output redfish)
      DROP VIEW IF EXISTS MetricReportCollection_JSON;
      CREATE VIEW MetricReportCollection_JSON as
        select
          json_patch(
            json_object(
              '@odata.context', '/redfish/v1/$metadata#MetricReportCollection.MetricReportCollection',
              '@odata.id', '/redfish/v1/TelemetryService/MetricReports',
              '@odata.type', '#MetricReportCollection.MetricReportCollection',
              'Name', 'MetricReports'),
            json(ifnull((
                SELECT
                  '{ "Members": ' ||  json_group_array( json_object('@odata.id', [@odata.id]) ) || ', ' ||
                  ' "Members@odata.count": ' ||  count(*) || '}'
                FROM MetricReport_JSON
                  ),  ' "Members":  [], "Members@odata.count":  0 '))
          ) as root,
          '/redfish/v1/TelemetryService/MetricReports' as [@odata.id]

  - |
      DROP VIEW IF EXISTS MetricReportDefinition_JSON;
      CREATE VIEW MetricReportDefinition_JSON as
        select
          (
          '{' ||
          ' "@odata.type": "#MetricReportDefinition.v1_2_0.MetricReportDefinition",' ||
          ' "@odata.context": "/redfish/v1/$metadata#MetricReportDefinition.MetricReportDefinition",' ||
          ' "@odata.id": "/redfish/v1/TelemetryService/MetricReportDefinitions/' || Name || '",' ||
          ' "Id": "' || name || '",' ||
          ' "Name": "' ||  ifnull(shortdesc, name || ' metric report definition') || '",' ||
          ' "Description": "' ||  ifnull(LongDesc, name || ' metric report definition') || '",' ||
            -- Hardcoded/fixed due to limitations in SQLITE query engine. LIMIT must be a constant
          ' "AppendLimit": 24000,' ||
          ' "MetricReportDefinitionEnabled": ' || case Enabled when 1 then json('true') else json('false') end || ',' ||
          ' "MetricReportDefinitionType": "' || Type || '",' ||
          ' "MetricReportDefinitionType@Redfish.AllowableValues": ' || json_array('Periodic', 'OnChange', 'OnRequest') || ', ' ||
          ' "MetricReportHeartbeatInterval": ' ||  '"PT' || ((HeartbeatInterval/1000000000)/(3600)) || 'H' || (((HeartbeatInterval/1000000000)/60)%60) || 'M' || ((HeartbeatInterval/1000000000)%60) || 'S",'  ||
          ' "SuppressRepeatedMetricValue": ' || case SuppressDups when 1 then json('true') else json('false') end || ',' ||
          ' "ReportTimespan": "PT' || (TimeSpan/(3600000000000)) || 'H' || ((TimeSpan/60000000000)%60) || 'M' || ((TimeSpan/1000000000)%60) || 'S' || '", ' ||
          ' "ReportUpdates": "' || Updates || '", ' ||
          ' "ReportUpdates@Redfish.AllowableValues": ' || json_array('AppendStopsWhenFull', 'AppendWrapsWhenFull', 'NewReport', 'Overwrite') || ", " ||

          ' "ReportActions": ' || json(Actions) || ',' ||
          ' "ReportActions@odata.count": ' || json_array_length(json(Actions)) || ',' ||
          ' "ReportActions@Redfish.AllowableValues": ' || json_array('LogToMetricReportsCollection', 'RedfishEvent') || ',' ||
          -- unsupported right now, so hardcoded:
          ' "Wildcards": [], "Wildcards@odata.count": 0, ' ||
          case Type
          when 'Periodic' then
          ' "Schedule": ' || json_object(
              'RecurrenceInterval', 'PT' || ((Period/1000000000)/(3600)) || 'H' || (((Period/1000000000)/60)%60) || 'M' || ((Period/1000000000)%60) || 'S'
            ) || ','
          else ''
          end ||
          ' "MetricReport": ' || IFNULL((
                select
                  json_object( '@odata.id', '/redfish/v1/TelemetryService/MetricReports/' || Name )
                from MetricReport as MR
                where MR.ReportDefinitionID = MetricReportDefinition.ID
                order by MR.Sequence DESC
                LIMIT 1
                ), 'null') || ',' ||
          ifnull((
            SELECT
            ' "Metrics": ' ||  json('[' ||  group_concat(a.JSON) || ']') || ',' ||
            ' "Metrics@odata.count": ' ||  count(*)
            FROM
            (
              select
                json_object(
                  'MetricId',
                    CASE MM.NamePattern
                    WHEN '' THEN NULL
                    ELSE MM.NamePattern
                    END,
                  'CollectionFunction',
                    CASE MM.CollectionFunction
                    WHEN '' THEN NULL
                    ELSE MM.CollectionFunction
                    END,
                  'CollectionDuration',
                    CASE MM.CollectionDuration
                    WHEN 0 THEN NULL
                    ELSE 'PT' || (MM.CollectionDuration/(3600 * 1000000000)) || 'H' || ((MM.CollectionDuration/(60 * 1000000000))%60) || 'M' || ((MM.CollectionDuration/1000000000)%60) || 'S'
                    END,
                  'OEM', json_object(
                    'Dell', json_object(
                      'FQDD',
                        CASE MM.FQDDPattern
                        WHEN '' THEN NULL
                        ELSE MM.FQDDPattern
                        END,
                      'Source',
                        CASE MM.SourcePattern
                        WHEN '' THEN NULL
                        ELSE MM.SourcePattern
                        END
                    )
                  )
                ) as JSON
              from MetricMeta as MM
              inner join  ReportDefinitionToMetricMeta as rd2mm on rd2mm.MetaID = MM.ID
              where rd2mm.ReportDefinitionID = MetricReportDefinition.ID
              ) AS a ), '"Metrics": [], "Metrics@odata.count": 0' ) || ',' ||
       ' "Links": ' ||
         json_object (  'Triggers', (
           select
             json_group_array( json_object('@odata.id', '/redfish/v1/TelemetryService/Triggers/' ||
                (select RedfishID from Trigger where TriggerID = ID) ))
           from TriggerToMRD
           where TriggerToMRD.MetricReportDefinitionID = MetricReportDefinition.ID )) ||
          '}'
          ) as root,
          '/redfish/v1/TelemetryService/MetricReportDefinitions/' || Name as [@odata.id],
          Hidden as Hidden
        from MetricReportDefinition

  - |
      DROP VIEW IF EXISTS MetricReportDefinitionCollection_JSON;
      CREATE VIEW MetricReportDefinitionCollection_JSON as
        select
          json_patch(
            json_object(
              "@odata.context", "/redfish/v1/$metadata#MetricReportDefinitionCollection.MetricReportDefinitionCollection",
              "@odata.id", "/redfish/v1/TelemetryService/MetricReportDefinitions",
              "@odata.type", "#MetricReportDefinitionCollection.MetricReportDefinitionCollection",
              "Name", "MetricReportDefinitions"),
            json(ifnull((
                SELECT
                  '{ "Members": ' ||  json_group_array( json_object('@odata.id', [@odata.id]) ) || ', ' ||
                  ' "Members@odata.count": ' ||  count(*) || '}'
                FROM MetricReportDefinition_JSON
                  ),  ' "Members":  [], "Members@odata.count":  0 '))
          ) as root,
          '/redfish/v1/TelemetryService/MetricReportDefinitions' as [@odata.id]

  - |
      DROP VIEW IF EXISTS TelemetryService_JSON;
      CREATE VIEW TelemetryService_JSON as
      select
        json_object(
          '@odata.context', '/redfish/v1/$metadata#TelemetryService.TelemetryService',
          '@odata.id', '/redfish/v1/TelemetryService',
          '@odata.type', '#TelemetryService.v1_1_1.TelemetryService',
          'Actions', json_object(
            '#TelemetryService.SubmitTestMetricReport', json_object(
              'target', '/redfish/v1/TelemetryService/Actions/TelemetryService.SubmitTestMetricReport'
            )
          ),
          'Id', 'TelemetryService',
          'Name', 'TelemetryService',
          'MetricDefinitions', json_object(
            '@odata.id', '/redfish/v1/TelemetryService/MetricDefinitions'
          ),
          'MetricReportDefinitions', json_object(
            '@odata.id', '/redfish/v1/TelemetryService/MetricReportDefinitions'
          ),
          'MetricReports', json_object(
            '@odata.id', '/redfish/v1/TelemetryService/MetricReports'
          ),
          'Triggers', json_object(
            '@odata.id', '/redfish/v1/TelemetryService/Triggers'
          )
        ) as root,
        '/redfish/v1/TelemetryService' as [@odata.id]

  - |
      -- This is the table that creates a uniform table name to gather *any* metric report, regardless of type
      DROP VIEW IF EXISTS JSON;
      CREATE VIEW JSON as
        select root, [@odata.id] from MetricReportDefinitionCollection_JSON
          UNION ALL
        select root, [@odata.id] from MetricReportDefinition_JSON
          UNION ALL
        select root, [@odata.id] from MetricReportCollection_JSON
          UNION ALL
        select root, [@odata.id] from MetricDefinitionCollection_JSON
          UNION ALL
        select root, [@odata.id] from MetricDefinition_JSON
          UNION ALL
        select root, [@odata.id] from MetricReport_JSON
          UNION ALL
        select root, [@odata.id] from TelemetryService_JSON
             UNION ALL
        select root, [@odata.id] from Trigger_JSON
             UNION ALL
         select root, [@odata.id] from TriggerCollectionView_JSON

# Backwards compat stuff to get the fcgi_rfsql to work. Drop the tables in a separate statement because it can error out (and be ignored)
  - |
      DROP TABLE IF EXISTS TblMetricReportItems;
  - |
      DROP VIEW IF EXISTS TblMetricReportItems;
  - |
      CREATE VIEW         TblMetricReportItems AS
        SELECT
          Name as ResourceType,
          '/redfish/v1/TelemetryService/MetricReports/' || Name as '@odata.id'
        FROM
          MetricReport;

# Backwards compat stuff to get the fcgi_rfsql to work. Drop the tables in a separate statement because it can error out (and be ignored)
  - |
      DROP TABLE IF EXISTS TblMetricReportDefinitionItems;
  - |
      DROP VIEW IF EXISTS TblMetricReportDefinitionItems;
  - |
      CREATE VIEW         TblMetricReportDefinitionItems AS
        SELECT
          Name as ResourceType,
          '/redfish/v1/TelemetryService/MetricReportDefinitions/' || Name as '@odata.id'
        FROM
          MetricReportDefinition;

  - |
      DROP VIEW IF EXISTS TblTelemetryAttributesRFEnable;
      CREATE VIEW         TblTelemetryAttributesRFEnable AS
        SELECT
          'Enabled' as CurrentValue,
          'iDRAC.Embedded.1#Redfish.1#Enable' as Key

  - |
      DROP VIEW IF EXISTS TblTelemetryAttributesTelemEnable;
      CREATE VIEW         TblTelemetryAttributesTelemEnable AS
        SELECT
          'Enabled' as CurrentValue,
          'iDRAC.Embedded.1#Telemetry.1#EnableTelemetry' as Key

  - |
      DROP VIEW IF EXISTS TblTelemetryAttributesREPORT;
      CREATE VIEW         TblTelemetryAttributesREPORT AS
        SELECT
          CASE MRD.Enabled
          WHEN true then 'Enabled'
          WHEN false then 'Disabled'
          END as CurrentValue,
          'iDRAC.Embedded.1#Telemetry' || Name || '.1#EnableTelemetry'  as Key
        FROM
          MetricReportDefinition as MRD

# TODO: currently gets default values a current triggers, need to reflect config
  - |
      CREATE VIEW IF NOT EXISTS TblTelemetryAttributesReportTrigger AS
        SELECT
          TriggerId as CurrentValue,
          'iDRAC.Embedded.1#Telemetry' || Name || '.1#ReportTriggers'  as Key
        FROM
          MetricReport, TblTriggerMetricReport
        WHERE
          instr(MetricReport, Name) > 0

  - |
      CREATE VIEW IF NOT EXISTS TblTelemetryAttributes AS
        SELECT * FROM TblTelemetryAttributesREPORT
        UNION ALL
        SELECT * FROM TblTelemetryAttributesRFEnable
        UNION ALL
        SELECT * FROM TblTelemetryAttributesTelemEnable
        UNION ALL
        SELECT REPLACE(group_concat(DISTINCT CurrentValue),',',','), Key from TblTelemetryAttributesReportTrigger GROUP BY Key

  - |
      CREATE TABLE IF NOT EXISTS TriggerToMRD
      (
        MetricReportDefinitionID      INTEGER not null,
        TriggerID			  INTEGER not null,

        -- indexes and constraints
        primary key (TriggerID, MetricReportDefinitionID)
        foreign key (TriggerID)
          references Trigger (ID)
            on delete cascade
        foreign key (MetricReportDefinitionID)
          references MetricReportDefinition (ID)
            on delete cascade
      );

  - |
      CREATE TABLE IF NOT EXISTS EventTriggers
      (
        ID          		  INTEGER NOT NULL PRIMARY KEY,
        EemiID      		  TEXT not null,
        TriggerID             INTEGER not null,

        -- indexes and constraints
        foreign key (TriggerID)
          references Trigger (ID)
            on delete cascade
      );

  - |
     CREATE TABLE IF NOT EXISTS Trigger
     (
       ID              INTEGER NOT NULL PRIMARY KEY,
       RedfishID       TEXT UNIQUE NOT NULL,
       Name            TEXT NOT NULL,
       Description     TEXT NOT NULL,
       MetricType      TEXT NOT NULL,
       TriggerActions  TEXT NOT NULL
     );

  - |
     -- 'MetricReport' in the column below is mistnmaed and is actually a MetricReportDefinition
     -- but have to keep this name for compat reasons
      CREATE VIEW IF NOT EXISTS TblTriggerMetricReport AS
      SELECT
        ET.EemiID as EemiId,
        Trigger.RedfishID as TriggerId,
        MRD.Name as MetricReport
      FROM EventTriggers as ET, TriggerToMRD as TR2MRD
      INNER JOIN Trigger ON Trigger.ID = ET.TriggerID
      INNER JOIN MetricReportDefinition as MRD ON
         TR2MRD.MetricReportDefinitionID = MRD.ID
      WHERE
         TR2MRD.TriggerID = Trigger.ID;

  - |
     CREATE VIEW IF NOT EXISTS Trigger_JSON AS
      SELECT
      (
       '{' ||
       ' "@odata.type": "#Triggers.v1_1_1.Triggers",' ||
       ' "@odata.context": "/redfish/v1/$metadata#Triggers.Triggers",' ||
       ' "@odata.id": "/redfish/v1/TelemetryService/Triggers/' || RedfishID || '",' ||
       ' "Id": "' || RedfishID || '",' ||
       ' "Name": "' || Name || '",' ||
       ' "Description": "' || Description || '",' ||
       ' "MetricType": "' || MetricType || '",' ||
       ' "TriggerActions": ' || TriggerActions || ',' ||
       ' "EventTriggers": ' ||
          (select json_group_array( EemiID) from EventTriggers where EventTriggers.TriggerID = Trigger.ID)  || ',' ||
       ' "EventTriggers@odata.count": ' ||
          (select count(EemiID) from EventTriggers where EventTriggers.TriggerID = Trigger.ID)  || ',' ||
       ' "Links": ' ||
         json_object (  'MetricReportDefinitions', (
           select
             json_group_array( json_object('@odata.id', '/redfish/v1/TelemetryService/MetricReportDefinitions/' ||
                (select Name from MetricReportDefinition where MetricReportDefinitionID = ID) ))
           from TriggerToMRD
           where TriggerToMRD.TriggerID = Trigger.ID )) ||
       '}'
       ) AS root,
            '/redfish/v1/TelemetryService/Triggers/' || RedfishID AS [@odata.id]
       FROM Trigger;

  - |
     CREATE VIEW IF NOT EXISTS TriggerCollection_JSON as
      select
      json_patch(
        json_object(
          "@odata.context", "/redfish/v1/$metadata#TriggerCollection.TriggerCollection",
          "@odata.id", "/redfish/v1/TelemetryService/Triggers",
          "@odata.type", "#TriggerCollection.TriggerCollection",
          "Name", "Triggers"),
        json(ifnull((
          SELECT
            '{ "Members": ' ||  json_group_array( json_object('@odata.id', [@odata.id]) ) || ', ' ||
            ' "Members@odata.count": ' ||  count(*) || '}'
          FROM Trigger_JSON
          ),  ' "Members":  [], "Members@odata.count":  0 '))
      )as root,
        '/redfish/v1/TelemetryService/Triggers' as [@odata.id]

  # Table populated at metric-engine start by reading MD jsons
  - |
     CREATE TABLE IF NOT EXISTS MetricDefinition
     (
       ID              INTEGER PRIMARY KEY,
       MetricId        TEXT UNIQUE NOT NULL,
       Name            TEXT NOT NULL,
       Description     TEXT NOT NULL,
       MetricType      TEXT NOT NULL,
       MetricDataType  TEXT NOT NULL,
       Units 	         TEXT,
       Accuracy        REAL,
       SensingInterval TEXT,
       DiscreteValues  TEXT
     );

  - |
     CREATE VIEW IF NOT EXISTS MetricDefinition_JSON as
      SELECT
      (
       '{' ||
       ' "@odata.type": "#MetricDefinition.v1_2_0.MetricDefinition",' ||
       ' "@odata.context": "/redfish/v1/$metadata#MetricDefinition.MetricDefinition",' ||
       ' "@odata.id": "/redfish/v1/TelemetryService/MetricDefinitions/' || MetricId || '",' ||
       ' "Id": "' || MetricId || '",' ||
       ' "Name": "' || Name || '",' ||
       ' "Description": "' || Description || '",' ||
       ' "MetricType": "' || MetricType || '",' ||
       ' "MetricDataType": "' || MetricDataType || '",' ||
       CASE WHEN Units = '' THEN '' ELSE ' "Units": "' || Units || '",'  END ||
       ' "Accuracy": ' || Accuracy || ',' ||
       ' "SensingInterval": "' || SensingInterval || '"' ||
       CASE WHEN DiscreteValues LIKE 'null' THEN '' ELSE ', "DiscreteValues": ' || DiscreteValues END ||
       '}'
       ) AS root,
            '/redfish/v1/TelemetryService/MetricDefinitions/' || MetricId AS [@odata.id]
       FROM MetricDefinition;

  - |
     CREATE VIEW IF NOT EXISTS MetricDefinitionCollection_JSON as
      select
      json_patch(
       json_object(
        "@odata.context", "/redfish/v1/$metadata#MetricDefinitionCollection.MetricDefinitionCollection",
        "@odata.id", "/redfish/v1/TelemetryService/MetricDefinitions",
        "@odata.type", "#MetricDefinitionCollection.MetricDefinitionCollection",
        "Name", "MetricDefinitions"),
       json(ifnull((
                SELECT
                  '{ "Members": ' ||  json_group_array( json_object('@odata.id', [@odata.id]) ) || ', ' ||
                  ' "Members@odata.count": ' ||  count(*) || '}'
                FROM MetricDefinition_JSON
                  ),  ' "Members":  [], "Members@odata.count":  0 '))
       ) as root,
       '/redfish/v1/TelemetryService/MetricDefinitions' as [@odata.id];

  - |
        DROP VIEW IF EXISTS AggregationMetricsMRView_json ; create view AggregationMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/AggregationMetrics';
        DROP VIEW IF EXISTS CPUMemMetricsMRView_json ; create view CPUMemMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/CPUMemMetrics';
        DROP VIEW IF EXISTS CPURegistersMRView_json ; create view CPURegistersMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/CPURegisters';
        DROP VIEW IF EXISTS CPUSensorMRView_json ; create view CPUSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/CPUSensor';
        DROP VIEW IF EXISTS CUPSMRView_json ; create view CUPSMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/CUPS';
        DROP VIEW IF EXISTS FCSensorMRView_json ; create view FCSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/FCSensor';
        DROP VIEW IF EXISTS FPGASensorMRView_json ; create view FPGASensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/FPGASensor';
        DROP VIEW IF EXISTS FanSensorMRView_json ; create view FanSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/FanSensor';
        DROP VIEW IF EXISTS GPUMetricsMRView_json ; create view GPUMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/GPUMetrics';
        DROP VIEW IF EXISTS GPUStatisticsMRView_json ; create view GPUStatisticsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/GPUStatistics';
        DROP VIEW IF EXISTS MemorySensorMRView_json ; create view MemorySensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/MemorySensor';
        DROP VIEW IF EXISTS NICSensorMRView_json ; create view NICSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/NICSensor';
        DROP VIEW IF EXISTS NICStatisticsMRView_json ; create view NICStatisticsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/NICStatistics';
        DROP VIEW IF EXISTS NVMeSMARTDataMRView_json ; create view NVMeSMARTDataMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/NVMeSMARTData';
        DROP VIEW IF EXISTS PSUMetricsMRView_json ; create view PSUMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/PSUMetrics';
        DROP VIEW IF EXISTS PowerMetricsMRView_json ; create view PowerMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/PowerMetrics';
        DROP VIEW IF EXISTS PowerStatisticsMRView_json ; create view PowerStatisticsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/PowerStatistics';
        DROP VIEW IF EXISTS SensorMRView_json ; create view SensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/Sensor';
        DROP VIEW IF EXISTS StorageDiskSMARTDataMRView_json ; create view StorageDiskSMARTDataMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/StorageDiskSMARTData';
        DROP VIEW IF EXISTS StorageSensorMRView_json ; create view StorageSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/StorageSensor';
        DROP VIEW IF EXISTS ThermalSensorMRView_json ; create view ThermalSensorMRView_json as select * from  JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/ThermalSensor';
        DROP VIEW IF EXISTS ThermalMetricsMRView_json ; create view ThermalMetricsMRView_json as select * from  JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/ThermalMetrics';

        DROP VIEW IF EXISTS MetricReportCollectionView_json ; create view MetricReportCollectionView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports';
        DROP VIEW IF EXISTS MetricReportDefinitionCollectionView_json ; create view MetricReportDefinitionCollectionView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReportDefinitions';
        DROP VIEW IF EXISTS TelemetryServiceView_json ; create view TelemetryServiceView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService';

        DROP VIEW IF EXISTS MetricDefinitionCollectionView_json ; create view MetricDefinitionCollectionView_json as select * from JSON  where [@odata.id] = '/redfish/v1/TelemetryService/MetricDefinitions';
        DROP VIEW IF EXISTS MetricDefinitionView_json ;           create view MetricDefinitionView_json as select * from JSON;
        DROP VIEW IF EXISTS TelemetryLogServiceLCLogview_json ;   -- create view TelemetryLogServiceLCLogview_json as select * from JSON;

# Logging levels:
# debug, info, warn, error, crit
#
# The 'logs' config is an ARRAY of output configurations. Below are the valid configuration options for each config.
#
# Enabled: disable or enable this specific logger entirely.
#       DEFAULT: disabled/false
#
# FileName: Specify "FileName" to send log output from that config to a file.
#       DEFAULT: /dev/stderr
#
# Level: will globally enable all logs at the specified level or higher. Leave this out to specify on a module by module basis
#       DEFAULT: (none) - no filtering, all logs output
#
# PrintFile: append the file name and line number of the location where the log function was called
#       DEFAULT: false
#
# PrintFunction: append the name of the function that called the log function
#       DEFAULT: false
#
# ModulesToEnable is an ARRAY
#   give 'name' to specify the name of a 'module', to show all output from all log statements tagged with that module (regardless of the global log level setting)
#   give 'level' to filter the module output to the specified log level and higher.
#
logs:
    # Log warnings and Crit to stderr
    - Enabled: true
      Level: "warn"
      PrintFile: false
      PrintFunction: false
      #FileName: "debug.log"
      ModulesToEnable:
        # ar sync can be disabled once we are more confident in it
        - name: "LegacyARSync"
          level: "info"
        - name: "ReportGeneration"
          level: "info"
