# main:  # we now have default values for everything here in the code. Can override on an as-needed basis
# udb: # moved udb-related paths under this top-level key. everything is in programtic defaults in code and can be overridden here

pprof: [ "unix:/run/telemetryservice/http.socket" ]
SSE: [ "unix:/run/telemetryservice/http.socket" ]
Redfish: [ "unix:/run/telemetryservice/http.socket" ]

##############################################
##
## MEB Questions: why do we have separate CurrentCUPS from the CIMVIEW_DCIM_NumericSensor table?
##
## TODO: CIMVIEW_DCIM_NumericSensorPS table -> make sure we are importing the metrics we need from here
##
##############################################

Startup-Events:
  ###########################################################################3
  ## Legacy reports
  ###########################################################################3
  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 60
    # "TelemetryAggregationMetrics.1.ReportInterval": 0,
    # AUDIT:
    #   [!] HAS DATA
    #       --> RESOURCE NOT FOUND
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "AggregationMetrics",
        "Name": "Aggregation Metrics Metric Report",
        "Description": "Aggregation Metrics report  is derived by applying a formula or filter to a set of base metric values for Power, Temperature, CUPS (CPU, Memory, IO, System)",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "OnRequest",
        "ReportTimespan": "PT60S",
        "ReportUpdates": "AppendWrapsWhenFull",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "SystemAvgInletTempHour"},
          {"MetricID": "SystemMaxInletTempHour"},
          {"MetricID": "SystemMaxPowerConsumption"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryCPUMemMetrics.1.ReportInterval": 60,
    # AUDIT:
    #   [x] HAS DATA
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "CPUMemMetrics",
        "Name": "CPU Mem Metrics Metric Report",
        "Description": "CPU Memory metrics",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "Metrics": [
          {"MetricID": "CPUC0ResidencyHigh"},
          {"MetricID": "CPUC0ResidencyLow"},
          {"MetricID": "CUPSIIOBandwidthDMI"},
          {"MetricID": "CUPSIIOBandwidthPort0"},
          {"MetricID": "CUPSIIOBandwidthPort1"},
          {"MetricID": "CUPSIIOBandwidthPort2"},
          {"MetricID": "CUPSIIOBandwidthPort3"},
          {"MetricID": "NonC0ResidencyHigh"},
          {"MetricID": "NonC0ResidencyLow"}
        ]
      }

  - name: AddMetricReportDefinition
    # "TelemetryCPURegisters.1.ReportInterval": 0,
    data: |
      { "Id": "CPURegisters",
        "Name": "CPU Register Dump Metric Report",
        "Description": "CPU Register dump (uuencoded binary data). This is platform specific. On Intel platform this represents the MSR registers and on AMD platform this represents the MCA registers. Please refer to OEM documentation on how to decode the binary data.",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "OnChange",
        "ReportUpdates": "AppendWrapsWhenFull",
        "SuppressRepeatedMetricValue": true,
        "ReportActions": [],
        "Metrics": []
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryCPUSensor.1.ReportInterval": 60,
    # AUDIT:
    #   [.] HAS DATA
    #       --> Empty report
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "CPUSensor",
        "Name": "CPU Sensor Metric Report",
        "Description": "CPU Sensor",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "TemperatureReading", "OEM": {"Dell": {"FQDD": "iDRAC.Embedded.1#CPU%Temp"}}},
          {"MetricID": "TemperatureReading", "OEM": {"Dell": {"FQDD": "CPU.Socket.%"}}}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryCUPS.1.ReportInterval": 60,
    # AUDIT:
    #   [.] HAS DATA
    #       --> Empty report
    #       --> Sailaja's idrac seems that the underlying cups table isn't being populated.
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "CUPS",
        "Name": "Compute Utilization Per Second (CUPS) Metric Report",
        "Description": "Compute Utilization Per Second  (percent). This report is platform dependent and the data may not be available on all platforms.",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "SuppressRepeatedMetricValue": false,
        "ReportUpdates": "Overwrite",
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "CPUUsage"},
          {"MetricID": "IOUsage"},
          {"MetricID": "MemoryUsage"},
          {"MetricID": "SystemUsage"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryFanSensor.1.ReportInterval": 60,
    # AUDIT:
    #   [x] HAS DATA
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "FanSensor",
        "Name": "Fan Sensor Metric Report",
        "Description": "Fan sensor",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "RPMReading", "OEM": {"Dell": {"Source": "fan"}}}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Need to limit this to FC via FQDD
    # TODO: Device Poll Frequency: 5
    # "TelemetryFCSensor.1.ReportInterval": 60,
    # AUDIT:
    #   [.] HAS DATA
    #       --> No FC in Sailaja's machine
    #       --> The metrics listed below *PROBABLY* have the wrong FQDDPattern anyways.
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    #
    # TODO: NOT SURE IF THE FQDDPATTERN IS RIGHT, DONT HAVE AN EXAMPLE
    data: |
      {
        "Id": "FCSensor",
        "Name": "FC Temperature Sensor Metric Report",
        "Description": "FC Temperature sensors",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "TemperatureReading", "OEM": {"Dell": {"FQDD": "FC.%"}}}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Need to limit this to FPGA via FQDD
    # TODO: Device Poll Frequency: 5
    # "TelemetryFPGASensor.1.ReportInterval": 60,
    # AUDIT:
    #   [.] HAS DATA
    #       --> No FPGA in Sailaja's machine
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "FPGASensor",
        "Name": "FPGA Temperature Sensors Metric Report",
        "Description": "FPGA(Field Programmable Gate Arrays) Temperature sensors",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "TemperatureReading", "OEM": {"Dell": {"Source": "fpga-sensor"}}}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryGPUMetrics.1.ReportInterval": 60,
    # AUDIT:
    #   [.] HAS DATA
    #       --> No GPU in Sailaja's machine
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "GPUMetrics",
        "Name": "GPU Health metrics Metric Report",
        "Description": "Graphics Processing Unit Health metrics",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "BoardPowerSupplyStatus"},
          {"MetricID": "BoardTemperature"},
          {"MetricID": "GPUHealth"},
          {"MetricID": "GPUStatus"},
          {"MetricID": "MemoryTemperature"},
          {"MetricID": "PowerBrakeState"},
          {"MetricID": "PowerConsumption"},
          {"MetricID": "PowerSupplyStatus"},
          {"MetricID": "PrimaryTemperature"},
          {"MetricID": "SecondaryTemperature"},
          {"MetricID": "ThermalAlertState"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 600
    # "TelemetryGPUStatistics.1.ReportInterval": 600,
    # AUDIT:
    #   [.] HAS DATA
    #       --> No GPU in Sailaja's machine
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "GPUStatistics",
        "Name": "GPU Statistics (experimental) Metric Report",
        "Description": "Graphics Processing Unit Frame Buffer and Graphic Device (GR) memory ECC(Error-correcting code) statistics data. This report is offered as an experimental preview.",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT600S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "CumulativeDBECounterFB"},
          {"MetricID": "CumulativeDBECounterGR"},
          {"MetricID": "CumulativeSBECounterFB"},
          {"MetricID": "CumulativeSBECounterGR"},
          {"MetricID": "DBECounterFB"},
          {"MetricID": "DBECounterFBL2Cache"},
          {"MetricID": "DBECounterGRL1Cache"},
          {"MetricID": "DBECounterGRRF"},
          {"MetricID": "DBECounterGRTex"},
          {"MetricID": "DBERetiredPages"},
          {"MetricID": "SBECounterFB"},
          {"MetricID": "SBECounterFBL2Cache"},
          {"MetricID": "SBECounterGRL1Cache"},
          {"MetricID": "SBECounterGRRF"},
          {"MetricID": "SBECounterGRTex"},
          {"MetricID": "SBERetiredPages"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryMemorySensor.1.ReportInterval": 60,
    # AUDIT:
    #   [.] HAS DATA
    #       --> empty report, should have data
    #       --> not getting udb events for memory sensor table updates?
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "MemorySensor",
        "Name": "Memory Sensor Metric Report",
        "Description": "Memory temperature sensor",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "TemperatureReading", "OEM": {"Dell": {"FQDD": "DIMM.Socket.%"}}}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryNICSensor.1.ReportInterval": 60,
    # AUDIT:
    #   [x] HAS DATA
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    #
    # Gets data from hiitempsensors query
    data: |
      {
        "Id": "NICSensor",
        "Name": "Network Card Sensor Metric Report",
        "Description": "Network Card temperature sensor",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "TemperatureReading", "OEM": {"Dell": {"FQDD": "NIC.%"}}}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 60
    # "TelemetryNICStatistics.1.ReportInterval": 60,
    # AUDIT:
    #   [x] HAS DATA
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "NICStatistics",
        "Name": "NIC Port and Partition Statistics  Metric Report",
        "Description": "NIC Port and Partition Statistics",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "DiscardedPkts"},
          {"MetricID": "FCCRCErrorCount"},
          {"MetricID": "FCOELinkFailures"},
          {"MetricID": "FCOEPktRxCount"},
          {"MetricID": "FCOEPktTxCount"},
          {"MetricID": "FCOERxPktDroppedCount"},
          {"MetricID": "LanFCSRxErrors"},
          {"MetricID": "LanUnicastPktRxCount"},
          {"MetricID": "LanUnicastPktTxCount"},
          {"MetricID": "LinkStatus"},
          {"MetricID": "OSDriverState"},
          {"MetricID": "PartitionLinkStatus"},
          {"MetricID": "PartitionOSDriverState"},
          {"MetricID": "RDMARxTotalBytes"},
          {"MetricID": "RDMARxTotalPackets"},
          {"MetricID": "RDMATotalProtectionErrors"},
          {"MetricID": "RDMATotalProtocolErrors"},
          {"MetricID": "RDMATxTotalBytes"},
          {"MetricID": "RDMATxTotalPackets"},
          {"MetricID": "RDMATxTotalReadReqPkts"},
          {"MetricID": "RDMATxTotalSendPkts"},
          {"MetricID": "RDMATxTotalWritePkts"},
          {"MetricID": "RxBroadcast"},
          {"MetricID": "RxBytes"},
          {"MetricID": "RxErrorPktAlignmentErrors"},
          {"MetricID": "RxErrorPktFCSErrors"},
          {"MetricID": "RxFalseCarrierDetection"},
          {"MetricID": "RxJabberPkt"},
          {"MetricID": "RxMutlicast"},
          {"MetricID": "RxPauseXOFFFrames"},
          {"MetricID": "RxPauseXONFrames"},
          {"MetricID": "RxRuntPkt"},
          {"MetricID": "RxUnicast"},
          {"MetricID": "TxBroadcast"},
          {"MetricID": "TxBytes"},
          {"MetricID": "TxErrorPktExcessiveCollision"},
          {"MetricID": "TxErrorPktLateCollision"},
          {"MetricID": "TxErrorPktMultipleCollision"},
          {"MetricID": "TxErrorPktSingleCollision"},
          {"MetricID": "TxMutlicast"},
          {"MetricID": "TxPauseXOFFFrames"},
          {"MetricID": "TxPauseXONFrames"},
          {"MetricID": "TxUnicast"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 3600
    # "TelemetryNVMeSMARTData.1.ReportInterval": 3600,
    # AUDIT:
    #   [.] HAS DATA
    #       --> sailaja's machine has no NVME
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "NVMeSMARTData",
        "Name": "NVMe SMART Data Metric Report",
        "Description": "NVMe SMART Health record",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT3600S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "AvailableSpare"},
          {"MetricID": "AvailableSpareThreshold"},
          {"MetricID": "CompositeTemparature"},
          {"MetricID": "ControllerBusyTimeLower"},
          {"MetricID": "ControllerBusyTimeUpper"},
          {"MetricID": "CriticalWarning"},
          {"MetricID": "DataUnitsReadLower"},
          {"MetricID": "DataUnitsReadUpper"},
          {"MetricID": "DataUnitsWrittenLower"},
          {"MetricID": "DataUnitsWrittenUpper"},
          {"MetricID": "HostReadCommandsLower"},
          {"MetricID": "HostReadCommandsUpper"},
          {"MetricID": "HostWriteCommandsLower"},
          {"MetricID": "HostWriteCommandsUpper"},
          {"MetricID": "MediaDataIntegrityErrorsLower"},
          {"MetricID": "MediaDataIntegrityErrorsUpper"},
          {"MetricID": "NumOfErrorInfoLogEntriesLower"},
          {"MetricID": "NumOfErrorInfoLogEntriesUpper"},
          {"MetricID": "PercentageUsed"},
          {"MetricID": "PowerCyclesLower"},
          {"MetricID": "PowerCyclesUpper"},
          {"MetricID": "PowerOnHoursLower"},
          {"MetricID": "PowerOnHoursUpper"},
          {"MetricID": "UnsafeShutdownsLower"},
          {"MetricID": "UnsafeShutdownsUpper"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryPowerMetrics.1.ReportInterval": 60,
    # AUDIT:
    #   [x] HAS DATA
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "PowerMetrics",
        "Name": "Power Metrics Metric Report",
        "Description": "Power consumption for all CPUs, DIMMs, System Input and System Output",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "SystemHeadRoomInstantaneous"},
          {"MetricID": "SystemInputPower"},
          {"MetricID": "SystemOutputPower"},
          {"MetricID": "SystemPowerConsumption"},
          {"MetricID": "TotalCPUPower"},
          {"MetricID": "TotalFanPower"},
          {"MetricID": "TotalMemoryPower"},
          {"MetricID": "TotalPciePower"},
          {"MetricID": "TotalStoragePower"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 60
    # "TelemetryPowerStatistics.1.ReportInterval": 60,
    # AUDIT:
    #   [x] HAS DATA
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "PowerStatistics",
        "Name": "Power Statistics Metric Report",
        "Description": "System power consumption statistics",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "OnChange",
        "ReportTimespan": "PT60S",
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "LastDayAvgPower"},
          {"MetricID": "LastDayMaxPower"},
          {"MetricID": "LastDayMaxPowerTime"},
          {"MetricID": "LastDayMinPower"},
          {"MetricID": "LastDayMinPowerTime"},
          {"MetricID": "LastHourAvgPower"},
          {"MetricID": "LastHourMaxPower"},
          {"MetricID": "LastHourMaxPowerTime"},
          {"MetricID": "LastHourMinPower"},
          {"MetricID": "LastHourMinPowerTime"},
          {"MetricID": "LastMinuteAvgPower"},
          {"MetricID": "LastMinuteMaxPower"},
          {"MetricID": "LastMinuteMaxPowerTime"},
          {"MetricID": "LastMinuteMinPower"},
          {"MetricID": "LastMinuteMinPowerTime"},
          {"MetricID": "LastWeekAvgPower"},
          {"MetricID": "LastWeekMaxPower"},
          {"MetricID": "LastWeekMaxPowerTime"},
          {"MetricID": "LastWeekMinPower"},
          {"MetricID": "LastWeekMinPowerTime"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 60
    # "TelemetryPSUMetrics.1.ReportInterval": 60,
    # AUDIT:
    #   [x] HAS DATA
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "PSUMetrics",
        "Name": "PSU Metric Report",
        "Description": "Power supply metrics",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "FanSpeed"},
          {"MetricID": "Temperature", "OEM": {"Dell": {"Source": "psu-sensor" }}}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetrySensor.1.ReportInterval": 60,
    # AUDIT:
    #   [x] HAS DATA
    #       --> looks like it's missing some data, or that the data isn't updated often enough from the source
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "Sensor",
        "Name": "IPMI Sensor Metric Report",
        "Description": "All IPMI Sensors",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "AmpsReading"},
          {"MetricID": "CPUUsagePctReading"},
          {"MetricID": "IOUsagePctReading"},
          {"MetricID": "MemoryUsagePctReading"},
          {"MetricID": "RPMReading", "OEM": {"Dell": {"Source": "rawsensor" }}},
          {"MetricID": "SystemUsagePctReading"},
          {"MetricID": "TemperatureReading", "OEM": {"Dell": {"Source": "rawsensor" }}},
          {"MetricID": "VoltageReading"},
          {"MetricID": "WattsReading"}
        ]
      }

  - name: AddMetricReportDefinition
    #"TelemetryStorageDiskSMARTData.1.ReportInterval": 3600,
    # TODO: Device Poll Frequency: 3600
    # AUDIT:
    #   [.] HAS DATA
    #       --> no sas drives on sailaja's machine? (this seems unlikely)
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "StorageDiskSMARTData",
        "Name": "Disk SMART Data Metric Report",
        "Description": "SSD SMART information",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT3600S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "CRCErrorCount", "OEM": {"Dell": {"Source": "smart-sas" }}},
          {"MetricID": "CommandTimeout"},
          {"MetricID": "CurrentPendingSectorCount"},
          {"MetricID": "DriveTemperature"},
          {"MetricID": "ECCERate"},
          {"MetricID": "EraseFailCount"},
          {"MetricID": "ExceptionModeStatus"},
          {"MetricID": "MediaWriteCount"},
          {"MetricID": "PercentDriveLifeRemaining"},
          {"MetricID": "PowerCycleCount"},
          {"MetricID": "PowerOnHours"},
          {"MetricID": "ProgramFailCount"},
          {"MetricID": "ReadErrorRate"},
          {"MetricID": "ReallocatedBlockCount"},
          {"MetricID": "UncorrectableErrorCount"},
          {"MetricID": "UncorrectableLBACount"},
          {"MetricID": "UnusedReservedBlockCount"},
          {"MetricID": "UsedReservedBlockCount"},
          {"MetricID": "VolatileMemoryBackupSourceFailures"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryStorageSensor.1.ReportInterval": 60,
    # AUDIT:
    #   [!] HAS DATA
    #       --> Has data initially, but source only sends changes, so the data goes stale
    #       --> TODO: need the "expand" feature to replay dups
    #       --> empty report. Missing HW?
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "StorageSensor",
        "Name": "Storage Sensor Metric Report",
        "Description": "Temperature information for the storage internal drives",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "TemperatureReading", "OEM": {"Dell": {"Source": "storage-sensor" }}}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryThermalMetrics.1.ReportInterval": 5,
    # AUDIT:
    #   [x] HAS DATA
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "ThermalMetrics",
        "Name": "Thermal Metrics Metric Report",
        "Description": "Thermal Metrics",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "OnChange",
        "ReportTimespan": "PT60S",
        "Schedule": {"RecurrenceInterval": "PT5S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "ComputePower", "OEM": {"Dell": {"Source": "thermalmetrics" }}},
          {"MetricID": "ITUE"},
          {"MetricID": "PSUEfficiency"},
          {"MetricID": "PowerToCoolRatio"},
          {"MetricID": "SysAirFlowEfficiency"},
          {"MetricID": "SysAirflowPerFanPower"},
          {"MetricID": "SysAirflowPerSysInputPower"},
          {"MetricID": "SysAirflowUtilization"},
          {"MetricID": "SysNetAirflow"},
          {"MetricID": "SysRackTempDelta"},
          {"MetricID": "TotalPSUHeatDissipation"}
        ]
      }

  - name: AddMetricReportDefinition
    # TODO: Device Poll Frequency: 5
    # "TelemetryThermalSensor.1.ReportInterval": 60,
    # AUDIT:
    #   [.] HAS DATA
    #       --> this one really should have data, but it's empty
    #   [ ] Correct Metric IDs
    #   [ ] Correct # of data points
    #   [ ] Data correct
    data: |
      {
        "Id": "ThermalSensor",
        "Name": "Thermal Sensor Metric Report",
        "Description": "Temperature Sensor",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "ReportUpdates": "Overwrite",
        "SuppressRepeatedMetricValue": false,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          { "MetricId": "TemperatureReading", "OEM": {"Dell": {"FQDD": "iDRAC.Embedded.1#SystemBoardInletTemp" }}},
          { "MetricId": "TemperatureReading", "OEM": {"Dell": {"FQDD": "iDRAC.Embedded.1#SystemBoardExhaustTemp" }}}
        ]
      }


  ###########################################################################3
  ## NEW reports
  ###########################################################################3
  - name: AddMetricReportDefinition
    data: |
      {
        "Id": "Thermal",
        "MetricReportDefinitionEnabled": true,
        "MetricReportDefinitionType": "Periodic",
        "ReportUpdates": "NewReport",
        "Schedule": {"RecurrenceInterval": "PT60S"},
        "SuppressRepeatedMetricValue": true,
        "ReportActions": ["RedfishEvent", "LogToMetricReportsCollection"],
        "Metrics": [
          {"MetricID": "TemperatureReading"},
          {"MetricID": "RPMReading"}
         ]
       }

UDB-Metric-Import:
  CurrentCUPS:
    Type: DirectMetric
    DBChange:
      SHM.db:
        TblsCurrentCUPS:
    ScanInterval: 0
    WaitInterval: 1
    Query: |
      SELECT
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as Context,

        SystemCupsTimeStamp * 1000000000 as Timestamp,
        SystemCupsCurrent as Value,
        'SystemUsage' as Name
      FROM TblsCurrentCUPS
      where Timestamp > :HWM
      UNION ALL

      SELECT
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as Context,

        MemoryCupsTimeStamp * 1000000000 as Timestamp,
        MemoryCupsCurrent as Value,
        'MemoryUsage' as Name
      FROM TblsCurrentCUPS
      where Timestamp > :HWM
      UNION ALL

      SELECT
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as Context,

        IoCupsTimestamp * 1000000000 as Timestamp,
        IoCupsCurrent as Value,
        'IOUsage' as Name
      FROM TblsCurrentCUPS
      where Timestamp > :HWM
      UNION ALL

      SELECT
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as Context,

        CpuCupsCollectionTime * 1000000000 as Timestamp,
        CpuCupsCurrent as Value,
        'CPUUsage' as Name
      FROM TblsCurrentCUPS
      where Timestamp > :HWM

  PowerStatistics:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsPowerStatistics:
    ScanInterval: 0
    # telemetrypop populates this table once per minute, dont scan more frequently than that.
    WaitInterval: 60
    # There is a TblAvgPowerConsumptionStatDataObj, why aren't we using that?
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB - 2020-03-10 - From Sailaja - backend reports every minute
        60000000000 as 'SensorInterval',
        5000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        LastWeekMinPowerTime as 'Metric-LastWeekMinPowerTime',
        LastWeekMinPower as 'Metric-LastWeekMinPower',
        LastWeekMaxPowerTime as 'Metric-LastWeekMaxPowerTime',
        LastWeekMaxPower as 'Metric-LastWeekMaxPower',
        LastWeekAvgPower as 'Metric-LastWeekAvgPower',

        LastDayMinPowerTime as 'Metric-LastDayMinPowerTime',
        LastDayMinPower as 'Metric-LastDayMinPower',
        LastDayMaxPowerTime as 'Metric-LastDayMaxPowerTime',
        LastDayMaxPower as 'Metric-LastDayMaxPower',
        LastDayAvgPower as 'Metric-LastDayAvgPower',

        LastHourMinPowerTime as 'Metric-LastHourMinPowerTime',
        LastHourMinPower as 'Metric-LastHourMinPower',
        LastHourMaxPowerTime as 'Metric-LastHourMaxPowerTime',
        LastHourMaxPower as 'Metric-LastHourMaxPower',
        LastHourAvgPower as 'Metric-LastHourAvgPower',

        LastMinuteMinPowerTime as 'Metric-LastMinuteMinPowerTime',
        LastMinuteMinPower as 'Metric-LastMinuteMinPower',
        LastMinuteMaxPowerTime as 'Metric-LastMinuteMaxPowerTime',
        LastMinuteMaxPower as 'Metric-LastMinuteMaxPower',
        LastMinuteAvgPower as 'Metric-LastMinuteAvgPower'

      FROM TblsPowerStatistics

  PowerMetrics:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsPowerMetrics:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB - 2/7/2020 - observed 5s, 10s, 15s, and 30s intervals. possibly suppressed upstream
        -- setting 5s sensor interval for now
        5000000000 as 'SensorInterval',  -- 5s interval w/ 2s slack
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        TotalStoragePower as 'Metric-TotalStoragePower',
        TotalPciePower as 'Metric-TotalPciePower',
        TotalMemoryPower as 'Metric-TotalMemoryPower',
        TotalFanPower as 'Metric-TotalFanPower',
        TotalCPUPower as 'Metric-TotalCPUPower',
        SystemPwrConsumption as 'Metric-SystemPowerConsumption',
        SystemHeadRoomInstantaneous as 'Metric-SystemHeadRoomInstantaneous',

        -- BUG IN UNDERLYING CODE -> this time stamp is reported in local time!
        -- THIS IS WRONG. WE HAVE TO FIX THIS UP HERE, BUT IT SHOULD BE FIXED IN UNDERLYING CODE
        -- CurrentSystemOutputTimeStamp * 1000000000 as 'Timestamp-SystemOutputPower',
        strftime('%s', CurrentSystemOutputTimeStamp, 'unixepoch', 'utc') as 'Timestamp-SystemOutputPower',
        CurrentSystemOutputPower as 'Metric-SystemOutputPower',

        -- BUG IN UNDERLYING CODE -> this time stamp is reported in local time!
        -- THIS IS WRONG. WE HAVE TO FIX THIS UP HERE, BUT IT SHOULD BE FIXED IN UNDERLYING CODE
        -- CurrentSystemInputPowerTimeStamp * 1000000000 as 'Timestamp-SystemInputPower',
        strftime('%s', CurrentSystemInputPowerTimeStamp, 'unixepoch', 'utc') as 'Timestamp-SystemInputPower',
        CurrentSystemInputPower as 'Metric-SystemInputPower'
      FROM TblsPowerMetrics

  ThermalMetrics:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsThermalMetrics:
    ScanInterval: 0
    # telemetrypop populates this table once per 5sec, changing from 1 sec to 5 sec.
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB - 2020-02-07 - observed 5s, 10s, 15s, 20s, 25s interals. Typical is 5s. Possibly suppressed upstream
        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        TotalPSUHeatDissipation as 'Metric-TotalPSUHeatDissipation',
        SysRackTempDelta as 'Metric-SysRackTempDelta',
        SysNetAirflow as 'Metric-SysNetAirflow',
        SysAirflowUtilization as 'Metric-SysAirflowUtilization',
        SysAirflowPerSysInputPower as 'Metric-SysAirflowPerSysInputPower',
        SysAirflowPerFanPower as 'Metric-SysAirflowPerFanPower',
        SysAirFlowEfficiency as 'Metric-SysAirFlowEfficiency',
        PowerToCoolRatio as 'Metric-PowerToCoolRatio',
        PSUEfficiency as 'Metric-PSUEfficiency',
        ITUE as 'Metric-ITUE',
        ComputePower as 'Metric-ComputePower'
      FROM TblsThermalMetrics

  CPUMem:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsCpuMemMetrics:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB 2020-02-07 - observed mostly reliable 5s intervals. Sometimes 10s. Possibly suppressed upstream
        -- Sailaja 2020-03-11 backend i.e telemetrypop reports every 5s
        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        CpuMemoryMetrics_DOT_NonC0ResidencyLow_DOT_value as 'Metric-NonC0ResidencyLow',
        CpuMemoryMetrics_DOT_NonC0ResidencyHigh_DOT_value as 'Metric-NonC0ResidencyHigh',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthPort3_DOT_value as 'Metric-CUPSIIOBandwidthPort3',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthPort2_DOT_value as 'Metric-CUPSIIOBandwidthPort2',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthPort1_DOT_value as 'Metric-CUPSIIOBandwidthPort1',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthPort0_DOT_value as 'Metric-CUPSIIOBandwidthPort0',
        CpuMemoryMetrics_DOT_CUPSIIOBandwidthDMI_DOT_value as 'Metric-CUPSIIOBandwidthDMI',
        CpuMemoryMetrics_DOT_CPUC0ResidencyLow_DOT_value as 'Metric-CPUC0ResidencyLow',
        CpuMemoryMetrics_DOT_CPUC0ResidencyHigh_DOT_value as 'Metric-CPUC0ResidencyHigh'
      FROM TblsCpuMemMetrics

  PSU-Sensor:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsPSUMetrics:
    ScanInterval: 0
    WaitInterval: 60
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB 2020-02-07 - observed mostly reliable 5s intervals. Sometimes 10s. Possibly suppressed upstream
        -- Sailaja 2020-03-11 Backend i.e telemetrypop reports every minute.
        60000000000 as 'SensorInterval',  -- 60s interval w/ 5s slack
        5000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        Temperature as 'Metric-TemperatureReading',
        FanSpeed as 'Metric-RPMReading'
      FROM TblsPSUMetrics

  Storage-Sensor:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsStorageSensor:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB 2020-02-07 - TODO -> Need info from Sailaja about the intervals here
        -- My data set has no recurrence on these values, bug in telemetrypop? Or are they really not changing? Too much suppression happening.
        -- TODO FIXME - going to hardcode this as 20s for now
        -- Sailaja - we need to check this, because backend reports only if there is a change, so should expand happen?
        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        CurrentReading as 'Metric-TemperatureReading'
      FROM TblsStorageSensor

  Memory-Sensor:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsMemorySensor:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB 2020-02-07 - TODO -> Need info from Sailaja about the intervals here
        -- My data set has no recurrence on these values, bug in telemetrypop? Or are they really not changing? Too much suppression happening.
        -- TODO FIXME - going to hardcode this as 20s for now
        -- Sailaja - we need to check this, because backend reports only if there is a change, so should expand happen?
        5000000000 as 'SensorInterval',
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        CurrentReading as 'Metric-TemperatureReading'
      FROM TblsMemorySensor

  FPGA-Sensor:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsFPGASensor:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        friendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FriendlyFQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB 2020-02-07 - TODO -> Need info from Sailaja about the intervals here
        -- No hardware in MEB test machine. Need info.
        -- TODO FIXME - going to hardcode this as 20s for now
        -- Sailaja - we need to check this, because backend reports only if there is a change, so should expand happen?
        5000000000 as 'SensorInterval',  -- 5s interval w/ 1s slack
        1000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        CurrentReading as 'Metric-TemperatureReading'
      FROM TblsFPGASensor

  Aggregation-Metrics:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: MetricColumns
    DBChange:
      SHM.db:
        TblsAggregationMetrics:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        -- only artificial available for now
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        FriendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        -- MEB 2020-02-07 - observed ~60s regular intervals here, but occasional 5s. WTF?
        -- TODO - investigate sensor interval here
        -- Sailaja - we need to check this, because reportinterval for this is zero & devicepoll is 60 sec?
        60000000000 as 'SensorInterval',
        5000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        SystemMaxPowerConsumption as 'Metric-SystemMaxPowerConsumption',
        SystemMaxInletTempHour as 'Metric-SystemMaxInletTempHour',
        SystemAvgInletTempHour as 'Metric-SystemAvgInletTempHour'
      FROM TblsAggregationMetrics

  SMART-NVME:
    Type: MetricColumns
    DBChange:
      DMLiveObjectDatabase.db:
        TblRAID_PDSmartData_NVMe:
    # underlying table has change support *AND* HWM, so no need to be stingy
    # ScanInterval: 600
    ScanInterval: 30
    WaitInterval: 5
    Query: |
      SELECT
        lastUpdatedDateTime * 1000000000 as Timestamp,
        FQDD as Context,
         '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,
        -- Sailaja - 2020-03-11 what about the expand for this? And waitinterval as reportinterval is big 3600 sec.        

        smartData_DOT_percentageUsed as 'Metric-PercentageUsed',
        smartData_DOT_criticalWarning as 'Metric-CriticalWarning',
        smartData_DOT_compositeTemparature as 'Metric-CompositeTemperature',
        smartData_DOT_compositeTemparature as 'Metric-TemperatureReading',                  -- Add standard TemperatureReading metric
        smartData_DOT_availableSpareThreshold as 'Metric-AvailableSpareThreshold',
        smartData_DOT_availableSpare as 'Metric-AvailableSpare',
        smartData_DOT_UnsafeShutdowns_DOT_Upper as 'Metric-UnsafeShutdownsUpper',
        smartData_DOT_UnsafeShutdowns_DOT_Lower as 'Metric-UnsafeShutdownsLower',
        smartData_DOT_PowerOnHours_DOT_Upper as 'Metric-PowerOnHoursUpper',
        smartData_DOT_PowerOnHours_DOT_Lower as 'Metric-PowerOnHoursLower',
        smartData_DOT_PowerCycles_DOT_Upper as 'Metric-PowerCyclesUpper',
        smartData_DOT_PowerCycles_DOT_Lower as 'Metric-PowerCyclesLower',
        smartData_DOT_NumOfErrorInfoLogEntries_DOT_Upper as 'Metric-NumOfErrorInfoLogEntriesUpper',
        smartData_DOT_NumOfErrorInfoLogEntries_DOT_Lower as 'Metric-NumOfErrorInfoLogEntriesLower',
        smartData_DOT_MediaAndDataIntegrityErrs_DOT_Upper as 'Metric-MediaDataIntegrityErrorsUpper',
        smartData_DOT_MediaAndDataIntegrityErrs_DOT_Lower as 'Metric-MediaDataIntegrityErrorsLower',
        smartData_DOT_HostWriteCmds_DOT_Upper as 'Metric-HostWriteCommandsUpper',
        smartData_DOT_HostWriteCmds_DOT_Lower as 'Metric-HostWriteCommandsLower',
        smartData_DOT_HostReadCmds_DOT_Upper as 'Metric-HostReadCommandsUpper',
        smartData_DOT_HostReadCmds_DOT_Lower as 'Metric-HostReadCommandsLower',
        smartData_DOT_DataUnitsWritten_DOT_Upper as 'Metric-DataUnitsWrittenUpper',
        smartData_DOT_DataUnitsWritten_DOT_Lower as 'Metric-DataUnitsWrittenLower',
        smartData_DOT_DataUnitsRead_DOT_Upper as 'Metric-DataUnitsReadUpper',
        smartData_DOT_DataUnitsRead_DOT_Lower as 'Metric-DataUnitsReadLower',
        smartData_DOT_ControllerBusyTime_DOT_Upper as 'Metric-ControllerBusyTimeUpper',
        smartData_DOT_ControllerBusyTime_DOT_Lower as 'Metric-ControllerBusyTimeLower'
      FROM TblRAID_PDSmartData_NVMe
      WHERE Timestamp > :HWM

  SMART-SAS:
    Type: MetricColumns
    # underlying table has change support *AND* HWM, so no need to be stingy
    #ScanInterval: 600
    ScanInterval: 30
    WaitInterval: 5
    DBChange:
      DMLiveObjectDatabase.db:
        TblRAID_PDSmartData_SAS_SATA:
    Query: |
      SELECT
        lastUpdatedDateTime * 1000000000 as Timestamp,
        FQDD as Context,
         '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        smartData_DOT_volatileMemoryBackupSourceFailures as 'Metric-VolatileMemoryBackupSourceFailures',
        smartData_DOT_usedReservedBlockCount as 'Metric-UsedReservedBlockCount',
        smartData_DOT_unusedReservedBlockCount as 'Metric-UnusedReservedBlockCount',
        smartData_DOT_uncorrectableLBACount as 'Metric-UncorrectableLBACount',
        smartData_DOT_uncorrectableErrorCount as 'Metric-UncorrectableErrorCount',
        smartData_DOT_reallocatedBlockCount as 'Metric-ReallocatedBlockCount',
        smartData_DOT_readErrorDate as 'Metric-ReadErrorRate',
        smartData_DOT_programFailCount as 'Metric-ProgramFailCount',
        smartData_DOT_powerOnHours as 'Metric-PowerOnHours',
        smartData_DOT_powerCycleCount as 'Metric-PowerCycleCount',
        smartData_DOT_percentDriveLifeRemaining as 'Metric-PercentDriveLifeRemaining',
        smartData_DOT_mediaWriteCount as 'Metric-MediaWriteCount',
        smartData_DOT_exceptionModeStatus as 'Metric-ExceptionModeStatus',
        smartData_DOT_eraseFailCount as 'Metric-EraseFailCount',
        smartData_DOT_driveTemperature as 'Metric-DriveTemperature',
        smartData_DOT_driveTemperature as 'Metric-TemperatureReading',                        -- Add temperature reading standard metric
        smartData_DOT_currentPendingSectorCount as 'Metric-CurrentPendingSectorCount',
        smartData_DOT_commandTimeout as 'Metric-CommandTimeout',
        smartData_DOT_ECCERate as 'Metric-ECCERate',
        smartData_DOT_CRCErrorCount as 'Metric-CRCErrorCount'
      FROM TblRAID_PDSmartData_SAS_SATA
      WHERE Timestamp > :HWM

  GPU-Statistics:
    Type: MetricColumns
    # SingleRecordEtag is the underlying HWM, so we can scan the table more often
    ScanInterval: 30
    WaitInterval: 1
    DBChange:
      DMLiveObjectDatabase.db:
        TblGPUStatisticsObj:
    Query: |
      SELECT
        SingleRecordEtag * 1000000000 as Timestamp,
        FQDD as Context,
         '/redfish/v1/FIXME/' || FQDD as Property,
        FQDD as FQDD,

        SBERetiredPages as 'Metric-SBERetiredPages',
        SBECounterGRTex as 'Metric-SBECounterGRTex',
        SBECounterGRRF as 'Metric-SBECounterGRRF',
        SBECounterGRL1CacheorSHM as 'Metric-SBECounterGRL1CacheorSHM',
        SBECounterFBL2Cache as 'Metric-SBECounterFBL2Cache',
        SBECounterFB as 'Metric-SBECounterFB',
        DBERetiredPages as 'Metric-DBERetiredPages',
        DBECounterGRTex as 'Metric-DBECounterGRTex',
        DBECounterGRTex as 'Metric-DBECounterGRTex',
        DBECounterGRRF as 'Metric-DBECounterGRRF',
        DBECounterGRL1CacheorSHM as 'Metric-DBECounterGRL1CacheorSHM',
        DBECounterFBL2Cache as 'Metric-DBECounterFBL2Cache',
        DBECounterFB as 'Metric-DBECounterFB',
        CumulativeSBECounterGR as 'Metric-CumulativeSBECounterGR',
        CumulativeDBECounterGR as 'Metric-CumulativeDBECounterGR',
        CumulativeDBECounterFB as 'Metric-CumulativeDBECounterFB'
      FROM TblGPUStatisticsObj
      WHERE Timestamp > :HWM

  GPU-Health:
    Type: MetricColumns
    # SingleRecordEtag is the underlying HWM, so we can scan the table more often
    ScanInterval: 10
    WaitInterval: 5
    DBChange:
      DMLiveObjectDatabase.db:
        TblGPUHealthObj:
    Query: |
      SELECT
        SingleRecordEtag * 1000000000 as Timestamp,
        FQDD as Context,
         '/redfish/v1/FIXME/' || FQDD as Property,
        FQDD as FQDD,

        ThermalAlertState as 'Metric-ThermalAlertState',
        SecondaryGpuTemp as 'Metric-SecondaryGpuTemp',
        PrimaryGpuTemp as 'Metric-PrimaryGpuTemp',
        PowerSupplyStatus as 'Metric-PowerSupplyStatus',
        PowerConsumption as 'Metric-PowerConsumption',
        PowerBrakeState as 'Metric-PowerBrakeState',
        MemoryTemp as 'Metric-MemoryTemp',
        GPUStatus as 'Metric-GPUStatus',
        GPUHealth as 'Metric-GPUHealth',
        BoardTemp as 'Metric-BoardTemp',
        BoardPowerSupplyStatus as 'Metric-BoardPowerSupplyStatus'
      FROM TblGPUHealthObj
      WHERE Timestamp > :HWM

  NICPortStats:
    Type: DISABLED
    # statistictime is the underlying HWM, so we can scan the table slightly more often
    ScanInterval: 0
    WaitInterval: 300
    # CIMVIEW_DCIM_NICStatistics is a VIEW, so do dbchange on the underlying table
    DBChange:
      DMLiveObjectDatabase.db:
        TblNic_Port_Stats_Obj:
        TblNic_Partition_Stats_Obj:
        TblSfp_Sensor_Obj:
        TblNic_RDMA_Stats_Obj:
    Query: |
      SELECT
        StatisticTime * 1000000000 as Timestamp,
        FQDD as Context,
         '/redfish/v1/FIXME/' || FQDD as Property,
        FQDD as FQDD,

        -- MEB 2020-02-07 - observed 5s intervals
        30000000000 as 'SensorInterval',  -- 5s interval w/ 1s slack
        5000000000 as 'SensorSlack',
        true as 'RequiresExpand',

        TxUnicast as 'Metric-TxUnicast',
        TxPauseXONFrames as 'Metric-TxPauseXONFrames',
        TxPauseXOFFFrames as 'Metric-TxPauseXOFFFrames',
        TxMutlicast as 'Metric-TxMutlicast',
        TxErrorPktSingleCollision as 'Metric-TxErrorPktSingleCollision',
        TxErrorPktMultipleCollision as 'Metric-TxErrorPktMultipleCollision',
        TxErrorPktLateCollision as 'Metric-TxErrorPktLateCollision',
        TxErrorPktExcessiveCollision as 'Metric-TxErrorPktExcessiveCollision',
        TxBytes as 'Metric-TxBytes',
        TxBroadcast as 'Metric-TxBroadcast',
        RxUnicast as 'Metric-RxUnicast',
        RxRuntPkt as 'Metric-RxRuntPkt',
        RxPauseXONFrames as 'Metric-RxPauseXONFrames',
        RxPauseXOFFFrames as 'Metric-RxPauseXOFFFrames',
        RxMutlicast as 'Metric-RxMutlicast',
        RxJabberPkt as 'Metric-RxJabberPkt',
        RxFalseCarrierDetection as 'Metric-RxFalseCarrierDetection',
        RxErrorPktFCSErrors as 'Metric-RxErrorPktFCSErrors',
        RxErrorPktAlignmentErrors as 'Metric-RxErrorPktAlignmentErrors',
        RxBytes as 'Metric-RxBytes',
        RxBroadcast as 'Metric-RxBroadcast',
        RDMATxTotalWritePkts as 'Metric-RDMATxTotalWritePkts',
        RDMATxTotalSendPkts as 'Metric-RDMATxTotalSendPkts',
        RDMATxTotalReadReqPkts as 'Metric-RDMATxTotalReadReqPkts',
        RDMATxTotalPackets as 'Metric-RDMATxTotalPackets',
        RDMATxTotalBytes as 'Metric-RDMATxTotalBytes',
        RDMATotalProtocolErrors as 'Metric-RDMATotalProtocolErrors',
        RDMATotalProtectionErrors as 'Metric-RDMATotalProtectionErrors',
        RDMARxTotalPackets as 'Metric-RDMARxTotalPackets',
        RDMARxTotalBytes as 'Metric-RDMARxTotalBytes',
        PartitionOSDriverState as 'Metric-PartitionOSDriverState',
        PartitionLinkStatus as 'Metric-PartitionLinkStatus',
        OSDriverState as 'Metric-OSDriverState',
        LinkStatus as 'Metric-LinkStatus',
        LanUnicastPktTXCount as 'Metric-LanUnicastPktTXCount',
        LanUnicastPktRXCount as 'Metric-LanUnicastPktRXCount',
        LanFCSRxErrors as 'Metric-LanFCSRxErrors',
        FCOERxPktDroppedCount as 'Metric-FCOERxPktDroppedCount',
        FCOEPktTxCount as 'Metric-FCOEPktTxCount',
        FCOEPktRxCount as 'Metric-FCOEPktRxCount',
        FCOELinkFailures as 'Metric-FCOELinkFailures',
        FCCRCErrorCount as 'Metric-FCCRCErrorCount',
        DiscardedPkts as 'Metric-DiscardedPkts',

        -- These dont seem to be populated in the embedded nics that I see. Possibly this is there for add-in cards
        Temperature as 'Metric-TemperatureReading',
        VoltageValue as 'Metric-VoltageReading'

        -- These are somewhat interesting in the underlying table. Need to see if we can output these as well
        --'RXInputPower'
        --'RXInputPowerStatus'     ,
        --'TXBiasCurrent'
        --'TXBiasCurrentStatus'    ,
        --'TXOutputPower'
        --'TXOutputPowerStatus'

      FROM CIMVIEW_DCIM_NICStatistics
      WHERE Timestamp > :HWM

  HIITempSensors:
    Type: MetricColumns
    ScanInterval: 0
    WaitInterval: 1
    DBChange:
      DMLiveObjectDatabase.db:
        TblHIISensorInfo_obj:
    Query: |
      SELECT
        SingleRecordEtag * 1000000000 as Timestamp,
        FriendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        currentTemp as 'Metric-TemperatureReading'
      FROM TblHIISensorInfo_obj
      WHERE Timestamp > :HWM

  Fan:
    Type: MetricColumns
    ScanInterval: 0
    WaitInterval: 1
    DBChange:
      DMLiveObjectDatabase.db:
        TblFanExtObj:
    Query: |
      SELECT
        UpdateTime * 1000000000 as Timestamp,
        FriendlyFQDD as Context,
        '/redfish/v1/FIXME/' || FQDD as Property,
        friendlyFQDD as FriendlyFQDD,
        FQDD as FQDD,

        VariableSpeed as 'Metric-RPMReading'
      from TblFanExtObj
      WHERE Timestamp > :HWM

  RAWSensor:
    Type: DirectMetric
    ScanInterval: 0
    WaitInterval: 5
    DBChange:
      DMLiveObjectDatabase.db:
        TblProbeObj:
    Query: |
      SELECT
        SingleRecordEtag * 1000000000 as Timestamp,
        ProbeLocation as Context,

        Key as FQDD,
        ProbeLocation as FriendlyFQDD,

        -- property not quite right, as PS sensors are an exception
        printf('/redfish/v1/Dell/Systems/System.Embedded.1/DellNumericSensor/%s', replace(replace(Key, '|', '_0x7c_') , '#', '_0x23_')) as Property,

        CASE ObjType
        WHEN 0x16 then 'TemperatureReading'
        WHEN 0x17 then 'RPMReading'
        WHEN 0x18 then 'VoltageReading'
        WHEN 0x19 then
          CASE subtype
            WHEN 0x17 THEN 'AmpsReading'
            WHEN 0x19 THEN 'WattsReading'
            WHEN 0x18 THEN 'AmpsReading'
            WHEN 0x1a THEN 'WattsReading'
          END
        WHEN 56 then
          CASE key
          WHEN 'iDRAC.Embedded.1#SystemBoardCPUUsage' then 'CPUUsage'
          WHEN 'iDRAC.Embedded.1#SystemBoardSYSUsage' then 'SystemUsage'
          WHEN 'iDRAC.Embedded.1#SystemBoardMEMUsage' then 'MemoryUsage'
          WHEN 'iDRAC.Embedded.1#SystemBoardIOUsage'  then 'IOUsage'
          END
        ELSE 'IGNORE'
        END as Name,

        -- manually expand x^y since sqlite is missing a pow() or exp() function
        CASE UnitModifier
        WHEN -6 THEN ProbeReading * 1000000.0
        WHEN -5 THEN ProbeReading * 100000.0
        WHEN -4 THEN ProbeReading * 10000.0
        WHEN -3 THEN ProbeReading * 1000.0
        WHEN -2 THEN ProbeReading * 100.0
        WHEN -1 THEN ProbeReading * 10.0
        WHEN  0 THEN ProbeReading * 1.0
        WHEN  1 THEN ProbeReading / 10.0
        WHEN  2 THEN ProbeReading / 100.0
        WHEN  3 THEN ProbeReading / 1000.0
        WHEN  4 THEN ProbeReading / 10000.0
        WHEN  5 THEN ProbeReading / 100000.0
        WHEN  6 THEN ProbeReading / 1000000.0
        END as Value

      FROM TblProbeObj
      left join
        ActiveOIDMapping on TblProbeObj.OID = ActiveOIDMapping.OID
      WHERE
        Timestamp > :HWM AND
        Name != 'IGNORE'

  Sensor:
    Type: DISABLED
    # TODO: UNDERLYING TABLE NEEDS HWM.
    # TODO: Underlying view table missing FQDD, need to add
    ScanInterval: 0
    WaitInterval: 5
    # CIMVIEW_DCIM_NumericSensor is a view, do db change notifications on underlying tables
    DBChange:
      DMLiveObjectDatabase.db:
        TblProbeObj:
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        case
          when SensorType = 1 then
          case
            when DeviceID = 'iDRAC.Embedded.1#SystemBoardCPUUsage' then 'CPUUsage'
            when DeviceID = 'iDRAC.Embedded.1#SystemBoardSYSUsage' then 'SystemUsage'
            when DeviceID = 'iDRAC.Embedded.1#SystemBoardMEMUsage' then 'MemoryUsage'
            when DeviceID = 'iDRAC.Embedded.1#SystemBoardIOUsage'  then 'IOUsage'
          end
          when SensorType = 2 then 'TemperatureReading'
          when SensorType = 3 then 'VoltageReading'
          when SensorType = 5 then 'RPMReading'
          else "InvalidMetric-" || SensorType
        end as Name,

        -- manually expand x^y since sqlite is missing a pow() or exp() function
        -- TODO: check that the positive/negative is correct here since this might be reversed
        CASE UnitModifier
        WHEN -6 THEN CurrentReading * 1000000.0
        WHEN -5 THEN CurrentReading * 100000.0
        WHEN -4 THEN CurrentReading * 10000.0
        WHEN -3 THEN CurrentReading * 1000.0
        WHEN -2 THEN CurrentReading * 100.0
        WHEN -1 THEN CurrentReading * 10.0
        WHEN  0 THEN CurrentReading * 1.0
        WHEN  1 THEN CurrentReading / 10.0
        WHEN  2 THEN CurrentReading / 100.0
        WHEN  3 THEN CurrentReading / 1000.0
        WHEN  4 THEN CurrentReading / 10000.0
        WHEN  5 THEN CurrentReading / 100000.0
        WHEN  6 THEN CurrentReading / 1000000.0
        END as Value,

        printf('/redfish/v1/Dell/Systems/System.Embedded.1/DellNumericSensor/%s', replace(replace(DeviceID, '|', '_0x7c_') , '#', '_0x23_')) as Property,
        ElementName as Context,
        DeviceID as FQDD,
        ElementName as FriendlyFQDD
      FROM CIMVIEW_DCIM_NumericSensor
      WHERE Timestamp > :HWM

  PSSensor:
    # TODO: UNDERLYING TABLE NEEDS HWM.
    Type: DISABLED
    # CIMVIEW_DCIM_PSNumericSensor is view, do db change on underlying tables
    DBChange:
      DMLiveObjectDatabase.db:
        TblProbeObj:
    ScanInterval: 0
    WaitInterval: 5
    Query: |
      SELECT
        cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer) as Timestamp,
        case SensorType
          when 13 then
          case
            when DeviceID = 'iDRAC.Embedded.1#SystemBoardPwrConsumption' then 'SystemBoardPowerConsumption'
            when Description = "Power Supply Power Consumption" then "WattsReading"
            else 'InvalidMetric-' || DeviceID
          end
          else "InvalidMetric-" || SensorType
        end as Name,

        -- manually expand x^y since sqlite is missing a pow() or exp() function
        -- TODO: check that the positive/negative is correct here since this might be reversed
        CASE UnitModifier
        WHEN -6 THEN CurrentReading * 1000000.0
        WHEN -5 THEN CurrentReading * 100000.0
        WHEN -4 THEN CurrentReading * 10000.0
        WHEN -3 THEN CurrentReading * 1000.0
        WHEN -2 THEN CurrentReading * 100.0
        WHEN -1 THEN CurrentReading * 10.0
        WHEN  0 THEN CurrentReading * 1.0
        WHEN  1 THEN CurrentReading / 10.0
        WHEN  2 THEN CurrentReading / 100.0
        WHEN  3 THEN CurrentReading / 1000.0
        WHEN  4 THEN CurrentReading / 10000.0
        WHEN  5 THEN CurrentReading / 100000.0
        WHEN  6 THEN CurrentReading / 1000000.0
        END as Value,

        printf('/redfish/v1/Dell/Systems/System.Embedded.1/DellPSNumericSensor/%s', replace(replace(DeviceID, '|', '_0x7c_') , '#', '_0x23_')) as Property,
        ElementName as Context,
        DeviceID as FQDD,
        ElementName as FriendlyFQDD
      FROM CIMVIEW_DCIM_PSNumericSensor
      WHERE Timestamp > :HWM

internal:
  # we can put the sql statements that we use internally in metric engine here
  # two benefits:
  #   - reduced binary size: we get rid of the sql string from the process memory space
  #   - increased performance: get rid of the internal prepares that are done by the database driver, especially helps in inner loops
  #
  # Be aware: Viper will lower case all names of config keys, so just them here as lower case or people might get confused.
  #
  namedsql:
    md_insert: |
      INSERT INTO MetricDefinition
               ( MetricId, Name, Description, MetricType, MetricDataType, Units, Accuracy, SensingInterval, DiscreteValues)
        VALUES (:MetricID, :Name, :Description, :MetricType, :MetricDataType, :Units, :Accuracy, :SensingInterval, :DiscreteValues)

    mrd_insert: |
      INSERT INTO MetricReportDefinition
               ( Name,  ShortDesc,  LongDesc,  Enabled,  AppendLimit,  Type,  SuppressDups,  Actions,  Updates,  Period,  TimeSpan)
        VALUES (:Name, :ShortDesc, :LongDesc, :Enabled, :AppendLimit, :Type, :SuppressDups, :Actions, :Updates, :Period, :TimeSpan)

    mrd_update: |
      UPDATE MetricReportDefinition
      SET
        ShortDesc=:ShortDesc,
        LongDesc=:LongDesc,
        Enabled=:Enabled,
        AppendLimit=:AppendLimit,
        Type=:Type,
        SuppressDups=:SuppressDups,
        Actions=:Actions,
        Period=:Period,
        Updates=:Updates,
        TimeSpan=:TimeSpan
      WHERE
        Name=:Name

    find_mm: |
      select ID from MetricMeta where
        NamePattern=:NamePattern and
        SuppressDups=:SuppressDups and
        FQDDPattern=:FQDDPattern and
        SourcePattern=:SourcePattern and
        PropertyPattern=:PropertyPattern and
        Wildcards=:Wildcards and
        CollectionFunction=:CollectionFunction and
        CollectionDuration=:CollectionDuration

    insert_mm: |
      INSERT INTO MetricMeta
             ( NamePattern,  SuppressDups,  FQDDPattern,  SourcePattern,  PropertyPattern,  Wildcards,  CollectionFunction,  CollectionDuration)
      VALUES (:NamePattern, :SuppressDups, :FQDDPattern, :SourcePattern, :PropertyPattern, :Wildcards, :CollectionFunction, :CollectionDuration)

    delete_mr_by_id: delete from MetricReport where ReportDefinitionID=:MRDID

    insert_report: |
      -- TODO Need to also max the value from the starttimestamp with the passed in start value
      INSERT INTO MetricReport
              (Name, ReportDefinitionID, ReportTimestamp, Sequence, StartTimestamp)
      VALUES (
        :Name, :MRDID, :ReportTimestamp,
        IFNULL((SELECT MAX(sequence)+1 FROM MetricReport WHERE ReportDefinitionID=:MRDID), 0),
        IFNULL((SELECT MAX(ReportTimestamp) FROM MetricReport WHERE ReportDefinitionID=:MRDID), :Start)
        );

    keep_only_3_reports: |
      -- Ensure there are max 3 reports (NO-OP except for Type=NewReport... thats ok)
      DELETE FROM MetricReport
      WHERE Name IN (
        SELECT name FROM (
          SELECT
            MR.name AS Name,
            MR.ReportDefinitionID,
            MR.sequence AS Seq,
            MAX(MR2.Sequence) AS MS
          FROM MetricReport AS MR
          LEFT JOIN MetricReport AS MR2
          ON MR.ReportDefinitionID = MR2.ReportDefinitionID
          GROUP BY MR.Name
        )
        WHERE seq+2<MS
      );

    update_report_set_start_to_prev_timestamp: |
      UPDATE MetricReport
      SET StartTimestamp = ReportTimestamp
      WHERE Name = :Name

    update_report_ts_seq: |
      UPDATE MetricReport
      SET ReportTimestamp = :ReportTimestamp,
          Sequence = Sequence + 1
      WHERE Name = :Name

    update_report_start: |
      UPDATE MetricReport
      SET StartTimestamp = :Start
      WHERE Name = :Name

    find_metric_meta: |
      SELECT
        ID AS MetaID, FQDDPattern, SourcePattern, PropertyPattern, Wildcards, CollectionFunction, CollectionDuration, SuppressDups
      FROM MetricMeta
      WHERE
        (:Name LIKE NamePattern OR NamePattern = '') AND
        (:FQDD LIKE FQDDPattern OR FQDDPattern = '') AND
        (:Source LIKE SourcePattern OR SourcePattern = '') AND
        (:Property LIKE PropertyPattern OR PropertyPattern = '')

    insert_metric_instance: |
      INSERT INTO MetricInstance
             ( Name,  FQDD,  Property,  Context,  Function,                      Duration,  Label,  CollectionScratch, LastValue, LastTS,  FlushTime,  SuppressDups, Dirty,    RequiresExpand,    SensorInterval,    SensorSlack,  Source)
      VALUES (:Name, :FQDD, :Property, :Context, :CollectionFunction, :CollectionDuration, :Label, :CollectionScratch, '',        0,      :FlushTime, :SuppressDups, false, :MVRequiresExpand, :MVSensorInterval, :MVSensorSlack, :Source)

    find_metric_instance: |
      select
        MI.ID as InstanceID,
        MI.Dirty as Dirty,
        MI.Source as Source,
        MI.Name as Name,
        (select count(*) from MetricMetaToInstance as MMTI where MMTI.InstanceID = MI.ID and MMTI.MetaID = :MetaID) as HasAssocMM
      from MetricInstance as MI
      where
        MI.Name=:Name and
        MI.FQDD=:FQDD and
        MI.Property=:Property and
        MI.Context=:Context and
        MI.Function=:CollectionFunction and
        MI.Duration=:CollectionDuration

    set_metric_instance_dirty: |
      UPDATE MetricInstance set Dirty=true

    set_metric_instance_clean: |
      UPDATE MetricInstance set Dirty=false where ID=:InstanceID

    iterate_metric_instance: |
      select distinct
        MI.ID as InstanceID,
        MI.CollectionScratch,
        MI.LastTS,
        MI.LastValue,
        MI.FlushTime,
        MI.SuppressDups,
        MI.Function as CollectionFunction,
        MI.Duration as CollectionDuration,
        MI.Dirty,
        MI.RequiresExpand as MIRequiresExpand,
        MI.SensorInterval as MISensorInterval,
        MI.SensorSlack    as MISensorSlack
      from MetricInstance as MI
      where
        MI.Name=:Name and
        MI.FQDD=:FQDD and
        MI.Property=:Property and
        MI.Context=:Context

    iterate_metric_instance_for_report: |
      select distinct
        MI.ID as InstanceID,
        MI.Source as Source,
        MI.Name as Name,
        MI.CollectionScratch,
        MI.LastTS,
        MI.LastValue,
        MI.FlushTime,
        MI.SuppressDups,
        MI.Function as CollectionFunction,
        MI.Duration as CollectionDuration,
        MI.Dirty,
        MI.RequiresExpand as MIRequiresExpand,
        MI.SensorInterval as MISensorInterval,
        MI.SensorSlack    as MISensorSlack
      from MetricInstance as MI
      inner join MetricMetaToInstance as MMTI on MI.ID = MMTI.InstanceID
      inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
      where
        rd2mm.ReportDefinitionID = :ID


    update_metric_instance: |
      UPDATE MetricInstance
      SET LastTS=:LastTS, LastValue=:LastValue, CollectionScratch=:CollectionScratch, FlushTime=:FlushTime
      WHERE ID=:InstanceID

    count_report_records: |
        select
          count(*) as Count
        from MetricValue as MV
        inner join MetricMetaToInstance as MMTI on MV.InstanceID = MMTI.InstanceID
        inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
        WHERE
          ( rd2mm.ReportDefinitionID = :MRDID ) AND
          ( MV.Timestamp > :Start )

  sqlx:
    find_onchange_mrd_by_mm_instance: |
      select
        MRD.Name
      from MetricReportDefinition as MRD
      inner join ReportDefinitionToMetricMeta as rd2mm on MRD.ID = rd2mm.ReportDefinitionID
      inner join MetricMetaToInstance as MMTI on rd2mm.MetaID = MMTI.MetaID
      where MRD.Type = "OnChange" and MMTI.InstanceID = ?

    mrd_select_idbyname: SELECT ID FROM MetricReportDefinition where Name=?

    generic_get: select root from JSON where [@odata.id] = ?

    delete_mrd: delete from MetricReportDefinition where name=?
    delete_mr: delete from MetricReport where Name=?

    delete_mm_assoc: delete from ReportDefinitionToMetricMeta where ReportDefinitionID=?

    insert_mm_assoc: INSERT INTO ReportDefinitionToMetricMeta (ReportDefinitionID, MetaID) VALUES (?, ?)
    insert_mi_assoc: INSERT INTO MetricMetaToInstance (MetaID, InstanceID) VALUES (?, ?)

    query_mrds: SELECT ID, Name,  Enabled, AppendLimit, Type, SuppressDups, Actions, Updates FROM MetricReportDefinition

    delete_mvi: delete from MetricValueInt where Timestamp > (select Timestamp from MetricValueInt order by Timestamp Limit 1 Offset 100000)
    delete_mvr: delete from MetricValueReal where Timestamp > (select Timestamp from MetricValueReal order by Timestamp Limit 1 Offset 100000)
    delete_mvt: delete from MetricValueText where Timestamp > (select Timestamp from MetricValueText order by Timestamp Limit 1 Offset 50000)
    delete_old_mr: |
      --// Only should have max 3 "new" reports per Metric Report Definition
      -- somewhat complicated query, but not too bad...
      DELETE FROM MetricReport WHERE Name IN (
        SELECT
          Name
        FROM (
          SELECT
            MR.name AS Name,
            MR.ReportDefinitionID,
            MR.sequence AS Seq,
            MAX(MR2.Sequence) AS MS
          FROM
            MetricReport AS MR
          LEFT JOIN
            MetricReport AS MR2 ON MR.ReportDefinitionID = MR2.ReportDefinitionID
          GROUP BY
            MR.Name
        )
        WHERE Seq+2<MS
      )

    delete_old_mvi: |
      delete from MetricValueInt where (InstanceID, Timestamp) IN
      (
        select MVI.InstanceID, MVI.TimeStamp
        from MetricValueInt as MVI
        left join OldestMetricInstanceInReportInt as MITR on MVI.InstanceID = MITR.InstanceID
        where MVI.Timestamp < MITR.MinTS
      );
    delete_old_mvr: |
      delete from MetricValueReal where (InstanceID, Timestamp) IN
      (
        select MVR.InstanceID, MVR.TimeStamp
        from MetricValueReal as MVR
        left join OldestMetricInstanceInReportReal as MITR on MVR.InstanceID = MITR.InstanceID
        where MVR.Timestamp < MITR.MinTS
      );
    delete_old_mvt: |
      delete from MetricValueText where (InstanceID, Timestamp) IN
      (
        select MVT.InstanceID, MVT.TimeStamp
        from MetricValueText as MVT
        left join OldestMetricInstanceInReportText as MITR on MVT.InstanceID = MITR.InstanceID
        where MVT.Timestamp < MITR.MinTS
      );


    # delete orphans of all kinds.
    #   Metric Report Definitions (MRD) are the source of truth
    #    .. Delete any ReportDefinitionToMetricMeta that doesn't match an MRD
    #    .. Delete any ReportDefinitionToMetricMeta that doesn't match a MetricMeta
    #    XX Delete any MetricMeta that doesnt have a ReportDefinitionToMetricMeta entry
    #    XX Delete any MetricInstance that doesnt have a MetricMetaToInstance entry
    #    .. Delete any MetricValue without MetricInstance
    #
    # XX = complete
    # .. = Should be covered by foreign key cascade delete
    # oo = Should be covered by foreign key cascade delete, but double check
    delete_orphan_metricmeta: |
      DELETE FROM MetricMeta WHERE id IN
      (
        select mm.ID from MetricMeta as mm
          LEFT JOIN ReportDefinitionToMetricMeta as rd2mm on mm.ID = rd2mm.MetaID where rd2mm.MetaID is null
      )

    delete_orphan_metricinstance: |
      DELETE FROM MetricInstance WHERE id IN
      (
        select MI.ID as InstanceID from MetricInstance as MI
          LEFT JOIN MetricMetaToInstance as MMTI on MMTI.InstanceID = MI.ID where MMTI.InstanceID is null
      )

    find_mrd_by_id: |
      SELECT ID, Name,  Enabled, AppendLimit, Type, SuppressDups, Actions, Updates, Period, TimeSpan FROM MetricReportDefinition where ID=?

    find_mrd_by_name: |
      SELECT ID, Name,  Enabled, AppendLimit, Type, SuppressDups, Actions, Updates, Period, TimeSpan FROM MetricReportDefinition where Name=?

    insert_mv_int:  INSERT INTO MetricValueInt  (InstanceID, Timestamp, Value) VALUES (?, ?, ?)
    insert_mv_real: INSERT INTO MetricValueReal (InstanceID, Timestamp, Value) VALUES (?, ?, ?)
    insert_mv_text: INSERT INTO MetricValueText (InstanceID, Timestamp, Value) VALUES (?, ?, ?)
    optimize: pragma optimize
    shrink: pragma shrink_memory
    vacuum: vacuum

createdb:
  - "PRAGMA busy_timeout = 1000;"
  - "PRAGMA journal_size_limit=512;"
  - "PRAGMA foreign_keys = ON;"
  - "PRAGMA journal_mode = WAL;"
  - "PRAGMA synchronous = OFF;"
    # Need to test these for impacts to RAM and CPU usage:
  #  - "PRAGMA cache_size=4096;"
  #  - "PRAGMA cache_size=0;"
  - |
      CREATE TABLE IF NOT EXISTS MetricReportDefinition
      (
        ID                INTEGER PRIMARY KEY NOT NULL,
        Name              TEXT UNIQUE NOT NULL, -- Name of the metric report defintion. This is what shows up in the collection
        ShortDesc         TEXT not null default '',
        LongDesc          TEXT not null default '',
        Enabled           BOOLEAN not null default false,
        AppendLimit       INTEGER not null default 24000,
        Type              TEXT not null default 'OnRequest',           -- type of report: 'Periodic', 'OnChange', 'OnRequest'
        SuppressDups      BOOLEAN not null default true,
        Actions           TEXT not null default '[]',                  -- json array of options: 'LogToMetricReportsCollection', 'RedfishEvent'
        Updates           TEXT not null default 'AppendWrapsWhenFull', -- 'AppendStopsWhenFull', 'AppendWrapsWhenFull', 'NewReport', 'Overwrite'
        Period            INTEGER not null default 0,
        TimeSpan          INTEGER not null default 0,
        HeartbeatInterval INTEGER NOT NULL DEFAULT 0,
        NextHeartbeatTS   INTEGER NOT NULL DEFAULT 0,
        Hidden            BOOLEAN NOT NULL DEFAULT FALSE -- Not displayed to the user, only for internal use
      )

  - |
      CREATE TABLE IF NOT EXISTS MetricDefinition
      (
        ID      INTEGER PRIMARY KEY,
        Name    TEXT UNIQUE NOT NULL,
        Accuracy REAL,
        Calculable TEXT, -- 'NonCalculatable', 'NonSummable', 'Summable'
        CalculationAlgorithm TEXT
      )

  - |
      -- These always exist
      -- They are created when the report is created
      -- multiple reports can link to the same MetricMeta (many to many relationship)
      CREATE TABLE IF NOT EXISTS MetricMeta
      (
        ID                 INTEGER UNIQUE PRIMARY KEY NOT NULL,
        SuppressDups       BOOLEAN NOT NULL DEFAULT true,
        NamePattern        TEXT NOT NULL DEFAULT "",
        FQDDPattern        TEXT NOT NULL DEFAULT "",   -- Dell OEM extension to sort based on FQDD patterns
        SourcePattern      TEXT NOT NULL DEFAULT "",   -- Dell OEM extension to sort based on where we got the data from
        PropertyPattern    TEXT NOT NULL DEFAULT "",   -- /redfish/v1/some/uri/{with}/{wildcards}#Property
        Wildcards          TEXT NOT NULL DEFAULT "",   --{'wildcard': ['array','of', 'possible', 'replacements'], 'with': ['another', 'list', 'of', 'replacements']}
        CollectionFunction TEXT not null DEFAULT "",   -- 'sum', 'avg', 'min', 'max'
        CollectionDuration INTEGER NOT NULL DEFAULT 0,

        -- indexes and constraints
        unique (NamePattern, SuppressDups, FQDDPattern, SourcePattern, PropertyPattern, Wildcards, CollectionFunction, CollectionDuration)
      )

  - |
      CREATE TABLE IF NOT EXISTS ReportDefinitionToMetricMeta
        (
          ReportDefinitionID   integer not null,
          MetaID               integer not null,

          -- indexes and constraints
          primary key (ReportDefinitionID, MetaID)
          foreign key (ReportDefinitionID)
            references MetricReportDefinition (ID)
              on delete cascade
          foreign key (MetaID)
            references MetricMeta (ID)
              on delete cascade
        );
        CREATE INDEX IF NOT EXISTS report_definition_2_metric_meta_metric_meta_id_idx ON ReportDefinitionToMetricMeta(MetaID)

  - |
      CREATE TABLE IF NOT EXISTS MetricInstance
      (
        ID                INTEGER NOT NULL PRIMARY KEY,
        Name              TEXT    NOT NULL, -- actual metric name
        FQDD              TEXT    NOT NULL,
        Property          TEXT    NOT NULL, -- URI#Property
        Source            TEXT    NOT NULL DEFAULT '',
        Context           TEXT    NOT NULL, -- usually FQDD
        Function          TEXT    NOT NULL,
        Duration          INTEGER NOT NULL DEFAULT 0,
        Label             TEXT    NOT NULL, -- 'friendly FQDD' + 'metric name' + 'collectionfn'
        SuppressDups      BOOLEAN NOT NULL default true,
        CollectionScratch TEXT    NOT NULL, -- Scratch space used by calculation functions
        FlushTime         INTEGER,          -- Time at which any aggregated data should be flushed
        LastTS            INTEGER NOT NULL, -- Used to quickly suppress dups for this instance
        LastValue         TEXT    NOT NULL, -- Used to quickly suppress dups for this instance
        RequiresExpand    BOOLEAN NOT NULL DEFAULT TRUE, -- should we automatically expand gaps
        SensorInterval    INTEGER NOT NULL DEFAULT 0,    -- set to the backend interval
        SensorSlack       INTEGER NOT NULL DEFAULT 0,    -- how much subsequent timestamps can drift
        SourceTraceInfo   TEXT    NOT NULL DEFAULT '',   -- DB:ROWID -- can look for sqlite operation==(delete) and turn off sensor interval
        Dirty             BOOLEAN NOT NULL DEFAULT TRUE, -- set to dirty any time MRD changes, clean once a metric has been processed

        -- indexes and constraints
        unique (Name, FQDD, Property, Context, Function, Duration, SuppressDups)
      )

  - |
      CREATE TABLE IF NOT EXISTS MetricMetaToInstance
      (
        MetaID      integer not null,
        InstanceID  integer not null,

        -- indexes and constraints
        primary key (InstanceID, MetaID)
        foreign key (InstanceID)
          references MetricInstance (ID)
            on delete cascade
        foreign key (MetaID)
          references MetricMeta (ID)
            on delete cascade
      );
      CREATE INDEX IF NOT EXISTS metric_meta_to_instance_metaid_idx ON MetricMetaToInstance(InstanceID)

  - |
      CREATE TABLE IF NOT EXISTS MetricValueInt
      (
        InstanceID INTEGER NOT NULL,
        Timestamp  INTEGER NOT NULL,
        Value      INTEGER NOT NULL,

        -- indexes and constraints
        PRIMARY KEY (InstanceID, Timestamp),
        FOREIGN KEY (InstanceID)
          REFERENCES MetricInstance (ID) ON DELETE CASCADE
      ) WITHOUT ROWID;

  - |
      CREATE TABLE IF NOT EXISTS MetricValueReal
      (
        InstanceID INTEGER NOT NULL,
        Timestamp  INTEGER NOT NULL,
        Value      REAL    NOT NULL,

        -- indexes and constraints
        PRIMARY KEY (InstanceID, Timestamp),
        FOREIGN KEY (InstanceID)
          REFERENCES MetricInstance (ID) ON DELETE CASCADE
      ) WITHOUT ROWID;

  - |
      CREATE TABLE IF NOT EXISTS MetricValueText
      (
        InstanceID INTEGER NOT NULL,
        Timestamp  INTEGER NOT NULL,
        Value      TEXT    NOT NULL,

        -- indexes and constraints
        PRIMARY KEY (InstanceID, Timestamp),
        FOREIGN KEY (InstanceID)
          REFERENCES MetricInstance (ID) ON DELETE CASCADE
      ) WITHOUT ROWID;

  - |
      CREATE View IF NOT EXISTS MetricValue as
        -- order is important here. dont re-arrange these, or you will break things
        select InstanceID, Timestamp, Value from MetricValueText
        union all
        select InstanceID, Timestamp, Value from MetricValueInt
        union all
        select InstanceID, Timestamp, Value from MetricValueReal;

  - |
      CREATE INDEX IF NOT EXISTS metric_value_int_ts_xref_idx on MetricValueInt(Timestamp);
      CREATE INDEX IF NOT EXISTS metric_value_real_ts_xref_idx on MetricValueReal(Timestamp);
      CREATE INDEX IF NOT EXISTS metric_value_text_ts_xref_idx on MetricValueText(Timestamp);

  - |
      CREATE TABLE IF NOT EXISTS MetricReport
      (
        Name               TEXT PRIMARY KEY UNIQUE NOT NULL,
        ReportDefinitionID INTEGER NOT NULL,
        Sequence           INTEGER NOT NULL DEFAULT 0,
        StartTimestamp     INTEGER NOT NULL DEFAULT (strftime('%s', 'now') * 1000000000),
        ReportTimestamp    INTEGER NOT NULL DEFAULT (strftime('%s', 'now') * 1000000000),

        -- indexes and constraints
        FOREIGN KEY (ReportDefinitionID)
          REFERENCES MetricReportDefinition (ID) ON DELETE CASCADE
      );
      CREATE INDEX IF NOT EXISTS metric_report_xref_idx on MetricReport(ReportDefinitionID);

  - |
      -- all queries to display to the user should use this one, as timestamp fields are 'correct'
      DROP VIEW IF EXISTS MetricReport_calculated;;
      CREATE VIEW IF NOT EXISTS MetricReport_calculated as
        SELECT
          MR.Name as Name,
          MR.ReportDefinitionID,
          MR.Sequence,

          CASE MRD.Type
          WHEN 'Periodic' THEN MR.ReportTimestamp
          WHEN 'OnChange' THEN MR.ReportTimestamp
          WHEN 'OnRequest' THEN cast( (julianday('now') - 2440587.5)*86400 * 1000000000 as integer)
          ELSE 0
          END as ReportTimestamp,

          CASE MRD.Type
          WHEN 'Periodic' THEN
            CASE
            WHEN MRD.TimeSpan = 0 THEN MR.StartTimestamp
            WHEN MR.ReportTimestamp - MRD.TimeSpan < MR.StartTimestamp THEN  MR.ReportTimestamp - MRD.TimeSpan
            ELSE StartTimestamp
            END
          WHEN 'OnChange' THEN ReportTimestamp - MRD.TimeSpan
          WHEN 'OnRequest' THEN cast( (julianday('now') - 2440587.5)*86400 * 1000000000 - MRD.TimeSpan as integer)
          ELSE 0
          END as StartTimestamp

        FROM MetricReport as MR
        INNER JOIN MetricReportDefinition as MRD on MRD.ID = MR.ReportDefinitionID

  - |
      -- TODO: check scalability of this view (should be scalable)
      -- This doesnt have ORDER BY or LIMIT, so it wont by itself limit output, but that also means it will stream.
      DROP VIEW IF EXISTS MetricValueByReport;
      CREATE VIEW MetricValueByReport as
        select
          MR.Name as Name,
          MV.InstanceID,
          MV.Timestamp,
          json_object(
              'MetricId', MI.Name,
              'Timestamp', strftime('%Y-%m-%dT%H:%M:%fZ', MV.Timestamp/1000000000, 'unixepoch'),
              'MetricValue', MV.Value,
              'OEM', json_object(
                'Dell', json_object(
                  'Context', MI.Context,
                  'Label', MI.Label
                )
          )) as 'JSON'
        from MetricReport_calculated as MR
        inner join ReportDefinitionToMetricMeta as rd2mm on MR.ReportDefinitionID = rd2mm.ReportDefinitionID
        inner join MetricMetaToInstance as MMTI on rd2mm.MetaID = MMTI.MetaID
        inner join MetricInstance as MI on MMTI.InstanceID = MI.ID
        inner join MetricValue as MV on MI.ID = MV.InstanceID
        WHERE
          ( MV.Timestamp > MR.StartTimestamp ) AND
          ( MV.Timestamp <= MR.ReportTimestamp )

  - |
      -- TODO: check scalability of this view (PROBABLY DOESNT SCALE DUE TO GROUP BY)
      DROP VIEW IF EXISTS OldestMetricInstanceInReportInt;
      CREATE VIEW OldestMetricInstanceInReportInt as
        select
          MV.InstanceID as InstanceID,
          min(mv.timestamp) as MinTS
        from MetricValueInt as MV
        inner join MetricMetaToInstance as MMTI on MV.InstanceID = MMTI.InstanceID
        inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
        inner join MetricReport_calculated as MR on MR.ReportDefinitionID = rd2mm.ReportDefinitionID
        WHERE MV.Timestamp > MR.StartTimestamp
        group by MV.InstanceID

  - |
      -- TODO: check scalability of this view (PROBABLY DOESNT SCALE DUE TO GROUP BY)
      DROP VIEW IF EXISTS OldestMetricInstanceInReportReal;
      CREATE VIEW OldestMetricInstanceInReportReal as
        select
          MV.InstanceID as InstanceID,
          min(mv.timestamp) as MinTS
        from MetricValueReal as MV
        inner join MetricMetaToInstance as MMTI on MV.InstanceID = MMTI.InstanceID
        inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
        inner join MetricReport_calculated as MR on MR.ReportDefinitionID = rd2mm.ReportDefinitionID
        WHERE MV.Timestamp > MR.StartTimestamp
        group by MV.InstanceID

  - |
      -- TODO: check scalability of this view
      DROP VIEW IF EXISTS OldestMetricInstanceInReportText;
      CREATE VIEW OldestMetricInstanceInReportText as
        select
          MV.InstanceID as InstanceID,
          min(mv.timestamp) as MinTS
        from MetricValueText as MV
        inner join MetricMetaToInstance as MMTI on MV.InstanceID = MMTI.InstanceID
        inner join ReportDefinitionToMetricMeta as rd2mm on MMTI.MetaID = rd2mm.MetaID
        inner join MetricReport_calculated as MR on MR.ReportDefinitionID = rd2mm.ReportDefinitionID
        WHERE MV.Timestamp > MR.StartTimestamp
        group by MV.InstanceID

  - |
      -- DOES NOT SCALE:  This uses a temp table to spool the metric values. memory usage scales with # of records output.
      DROP VIEW IF EXISTS MetricReport_JSON;
      DROP VIEW IF EXISTS MetricReport_JSON;
      CREATE VIEW MetricReport_JSON as
      select
        ('{' ||
            ' "@odata.type": "#MetricReport.v1_2_0.MetricReport",' ||
            ' "@odata.context": "/redfish/v1/$metadata#MetricReport.MetricReport",' ||
            ' "@odata.id": "/redfish/v1/TelemetryService/MetricReports/' || MR.Name || '",' ||
            ' "Id": "' || MR.Name || '",' ||
            ' "Name": "' || MR.Name || ' Metric Report",' ||
            CASE MRD.Type
            WHEN 'Periodic' THEN ' "ReportSequence": ' || json_quote(Sequence) || ','
            WHEN 'OnChange' THEN ' "ReportSequence": ' || json_quote(Sequence) || ','
            ELSE ''
            END ||
            ' "Timestamp": ' || strftime('"%Y-%m-%dT%H:%M:%fZ"', MR.ReportTimestamp/1000000000, 'unixepoch') || ', ' ||
            ' "MetricReportDefinition": {"@odata.id": "/redfish/v1/TelemetryService/MetricReportDefinitions/' || MRD.Name || '"}, ' ||
              ifnull((
                SELECT
                  ' "MetricValues":  [' ||  group_concat(a.JSON) || '], ' ||
                  ' "MetricValues@odata.count": ' ||  count(*)
                FROM
                (
                  select JSON
                  from MetricValueByReport as MVR
                  where MVR.Name=MR.Name
                    order by MVR.Timestamp DESC
                    limit 24000
                  ) AS a ),  ' "MetricValues":  [], "MetricValues@odata.count":  0 ')
          || '}'
        ) as root,
        '/redfish/v1/TelemetryService/MetricReports/' || MR.Name as '@odata.id',
        Hidden as Hidden
      from MetricReport_calculated as MR
      inner join MetricReportDefinition as MRD on MRD.ID = MR.ReportDefinitionID

  - |
      -- DOES NOT SCALE:  This uses a temp table to spool the metric values. memory usage scales with # of records output.
      -- do not expect to have scaling issues with this table as we will
      -- generally have a low number of metric reports. just something to be aware
      -- of. Hopefully we can fix the design in the future to be more scalable
      -- (ie. not use sqlite to output redfish)
      DROP VIEW IF EXISTS MetricReportCollection_JSON;
      CREATE VIEW MetricReportCollection_JSON as
        select
          json_object(
            '@odata.context', '/redfish/v1/$metadata#MetricReportCollection.MetricReportCollection',
            '@odata.id', '/redfish/v1/TelemetryService/MetricReports',
            '@odata.type', '#MetricReportCollection.MetricReportCollection',
            'Name', 'MetricReports',
            'Members',
            (
            select
              json_group_array( json_object('@odata.id', [@odata.id]) )
            from MetricReport_JSON
            where Hidden != true
            )
          ) as root,
          '/redfish/v1/TelemetryService/MetricReports' as [@odata.id]

  - |
      DROP VIEW IF EXISTS MetricReportDefinition_JSON;
      CREATE VIEW MetricReportDefinition_JSON as
        select
          (
          '{' ||
          ' "@odata.type": "#MetricReportDefinition.v1_2_0.MetricReportDefinition",' ||
          ' "@odata.context": "/redfish/v1/$metadata#MetricReportDefinition.MetricReportDefinition",' ||
          ' "@odata.id": "/redfish/v1/TelemetryService/MetricReportDefinitions/' || Name || '",' ||
          ' "Id": "' || name || '",' ||
          ' "Name": "' ||  ifnull(shortdesc, name || ' metric report definition') || '",' ||
          ' "Description": "' ||  ifnull(LongDesc, name || ' metric report definition') || '",' ||
            -- Hardcoded/fixed due to limitations in SQLITE query engine. LIMIT must be a constant
          ' "AppendLimit": 24000,' ||
          ' "MetricReportDefinitionEnabled": ' || case Enabled when 1 then json('true') else json('false') end || ',' ||
          ' "MetricReportDefinitionType": "' || Type || '",' ||
          ' "MetricReportDefinitionType@Redfish.AllowableValues": ' || json_array('Periodic', 'OnChange', 'OnRequest') || ', ' ||
          ' "MetricReportHeartbeatInterval": ' ||  '"PT' || ((HeartbeatInterval/1000000000)/(3600)) || 'H' || (((HeartbeatInterval/1000000000)/60)%60) || 'M' || ((HeartbeatInterval/1000000000)%60) || 'S",'  ||
          ' "SuppressRepeatedMetricValue": ' || case SuppressDups when 1 then json('true') else json('false') end || ',' ||
          ' "ReportTimespan": "PT' || (TimeSpan/(3600000000000)) || 'H' || ((TimeSpan/60000000000)%60) || 'M' || ((TimeSpan/1000000000)%60) || 'S' || '", ' ||
          ' "ReportUpdates": "' || Updates || '", ' ||
          ' "ReportUpdates@Redfish.AllowableValues": ' || json_array('AppendStopsWhenFull', 'AppendWrapsWhenFull', 'NewReport', 'Overwrite') || ", " ||

          ' "ReportActions": ' || json(Actions) || ',' ||
          ' "ReportActions@odata.count": ' || json_array_length(json(Actions)) || ',' ||
          ' "ReportActions@Redfish.AllowableValues": ' || json_array('LogToMetricReportsCollection', 'RedfishEvent') || ',' ||
          case Type
          when 'Periodic' then
          ' "Schedule": ' || json_object(
              'RecurrenceInterval', 'PT' || ((Period/1000000000)/(3600)) || 'H' || (((Period/1000000000)/60)%60) || 'M' || ((Period/1000000000)%60) || 'S'
            ) || ','
          else ''
          end ||
          ' "MetricReport": ' || IFNULL((
                select
                  json_object( '@odata.id', '/redfish/v1/TelemetryService/MetricReports/' || Name )
                from MetricReport as MR
                where MR.ReportDefinitionID = MetricReportDefinition.ID
                order by MR.Sequence DESC
                LIMIT 1
                ), 'null') || ',' ||
          ifnull((
            SELECT
            ' "Metrics": ' ||  json('[' ||  group_concat(a.JSON) || ']') || ',' ||
            ' "Metrics@odata.count": ' ||  count(*)
            FROM
            (
              select
                json_object(
                  'MetricID',
                    CASE MM.NamePattern
                    WHEN '' THEN NULL
                    ELSE MM.NamePattern
                    END,
                  'CollectionFunction',
                    CASE MM.CollectionFunction
                    WHEN '' THEN NULL
                    ELSE MM.CollectionFunction
                    END,
                  'CollectionDuration',
                    CASE MM.CollectionDuration
                    WHEN 0 THEN NULL
                    ELSE 'PT' || (MM.CollectionDuration/(3600)) || 'H' || ((MM.CollectionDuration/60)%60) || 'M' || (MM.CollectionDuration%60) || 'S'
                    END,
                  'OEM', json_object(
                    'Dell', json_object(
                      'FQDD',
                        CASE MM.FQDDPattern
                        WHEN '' THEN NULL
                        ELSE MM.FQDDPattern
                        END,
                      'Source',
                        CASE MM.SourcePattern
                        WHEN '' THEN NULL
                        ELSE MM.SourcePattern
                        END
                    )
                  )
                ) as JSON
              from MetricMeta as MM
              inner join  ReportDefinitionToMetricMeta as rd2mm on rd2mm.MetaID = MM.ID
              where rd2mm.ReportDefinitionID = MetricReportDefinition.ID
              ) AS a ), '"Metrics": [], "Metrics@odata.count": 0' ) ||
          '}'
          ) as root,
          '/redfish/v1/TelemetryService/MetricReportDefinitions/' || Name as [@odata.id],
          Hidden as Hidden
        from MetricReportDefinition

  - |
      DROP VIEW IF EXISTS MetricReportDefinitionCollection_JSON;
      CREATE VIEW MetricReportDefinitionCollection_JSON as
        select
          json_object(
            "@odata.context", "/redfish/v1/$metadata#MetricReportDefinitionCollection.MetricReportDefinitionCollection",
            "@odata.id", "/redfish/v1/TelemetryService/MetricReportDefinitions",
            "@odata.type", "#MetricReportDefinitionCollection.MetricReportDefinitionCollection",
            "Name", "MetricReportDefinitions",
            'Members', (
              select
                json_group_array( json_object('@odata.id', [@odata.id]) )
              from MetricReportDefinition_JSON
              where Hidden != true
            )
          ) as root,
          '/redfish/v1/TelemetryService/MetricReportDefinitions' as [@odata.id]

  - |
      DROP VIEW IF EXISTS TelemetryService_JSON;
      CREATE VIEW TelemetryService_JSON as
      select
        json_object(
          '@odata.context', '/redfish/v1/$metadata#TelemetryService.TelemetryService',
          '@odata.id', '/redfish/v1/TelemetryService',
          '@odata.type', '#TelemetryService.v1_1_1.TelemetryService',
          'Actions', json_object(
            '#TelemetryService.SubmitTestMetricReport', json_object(
              'target', '/redfish/v1/TelemetryService/Actions/TelemetryService.SubmitTestMetricReport'
            )
          ),
          'Id', 'TelemetryService',
          'Name', 'TelemetryService',
          'MetricDefinitions', json_object(
            '@odata.id', '/redfish/v1/TelemetryService/MetricDefinitions'
          ),
          'MetricReportDefinitions', json_object(
            '@odata.id', '/redfish/v1/TelemetryService/MetricReportDefinitions'
          ),
          'MetricReports', json_object(
            '@odata.id', '/redfish/v1/TelemetryService/MetricReports'
          ),
          'Triggers', json_object(
            '@odata.id', '/redfish/v1/TelemetryService/Triggers'
          )
        ) as root,
        '/redfish/v1/TelemetryService' as [@odata.id]

  - |
      -- This is the table that creates a uniform table name to gather *any* metric report, regardless of type
      DROP VIEW IF EXISTS JSON;
      CREATE VIEW JSON as
        select root, [@odata.id] from MetricReportDefinitionCollection_JSON
          UNION ALL
        select root, [@odata.id] from MetricReportDefinition_JSON
          UNION ALL
        select root, [@odata.id] from MetricReportCollection_JSON
          UNION ALL
        select root, [@odata.id] from MetricDefinitionCollection_JSON
          UNION ALL
        select root, [@odata.id] from MetricDefinition_JSON
          UNION ALL
        select root, [@odata.id] from MetricReport_JSON
          UNION ALL
        select root, [@odata.id] from TelemetryService_JSON

# Backwards compat stuff to get the fcgi_rfsql to work. Drop the tables in a separate statement because it can error out (and be ignored)
  - |
      DROP TABLE IF EXISTS TblMetricReportItems;
  - |
      DROP VIEW IF EXISTS TblMetricReportItems;
  - |
      CREATE VIEW         TblMetricReportItems AS
        SELECT
          Name as ResourceType,
          '/redfish/v1/TelemetryService/MetricReports/' || Name as '@odata.id'
        FROM
          MetricReport;

# Backwards compat stuff to get the fcgi_rfsql to work. Drop the tables in a separate statement because it can error out (and be ignored)
  - |
      DROP TABLE IF EXISTS TblMetricReportDefinitionItems;
  - |
      DROP VIEW IF EXISTS TblMetricReportDefinitionItems;
  - |
      CREATE VIEW         TblMetricReportDefinitionItems AS
        SELECT
          Name as ResourceType,
          '/redfish/v1/TelemetryService/MetricReportDefinitions/' || Name as '@odata.id'
        FROM
          MetricReportDefinition;

  - |
      DROP VIEW IF EXISTS TblTelemetryAttributesRFEnable;
      CREATE VIEW         TblTelemetryAttributesRFEnable AS
        SELECT
          'Enabled' as CurrentValue,
          'iDRAC.Embedded.1#Redfish.1#Enable' as Key

  - |
      DROP VIEW IF EXISTS TblTelemetryAttributesTelemEnable;
      CREATE VIEW         TblTelemetryAttributesTelemEnable AS
        SELECT
          'Enabled' as CurrentValue,
          'iDRAC.Embedded.1#Telemetry.1#EnableTelemetry' as Key

  - |
      DROP VIEW IF EXISTS TblTelemetryAttributesREPORT;
      CREATE VIEW         TblTelemetryAttributesREPORT AS
        SELECT
          'Enabled' as CurrentValue,
          'iDRAC.Embedded.1#Telemetry' || Name || '.1#EnableTelemetry'  as Key
        FROM
          MetricReport
          
# TODO: currently gets default values a current triggers, need to reflect config         
  - |
      DROP VIEW IF EXISTS TblTelemetryAttributesReportTrigger;
      CREATE VIEW         TblTelemetryAttributesReportTrigger AS
        SELECT
          TriggerId as CurrentValue,
          'iDRAC.Embedded.1#Telemetry' || Name || '.1#ReportTriggers'  as Key
        FROM
          MetricReport, TblTriggerMetricReport
        WHERE
          instr(MetricReport, Name) > 0

  - |
      DROP VIEW IF EXISTS TblTelemetryAttributes;
      CREATE VIEW         TblTelemetryAttributes AS
        SELECT * FROM TblTelemetryAttributesREPORT
        UNION ALL
        SELECT * FROM TblTelemetryAttributesRFEnable
        UNION ALL
        SELECT * FROM TblTelemetryAttributesTelemEnable
        UNION ALL
        SELECT REPLACE(group_concat(DISTINCT CurrentValue),',',','), Key from TblTelemetryAttributesReportTrigger GROUP BY Key
        
  - |        
     DROP TABLE IF EXISTS TblTriggerMetricReport;
      CREATE TABLE IF NOT EXISTS TblTriggerMetricReport
      (
        EemiId TEXT,
        TriggerId TEXT,
        MetricReport TEXT
      );    
    
  - |
     INSERT INTO TblTriggerMetricReport ( EemiId, TriggerId, MetricReport )
      VALUES
      ('iDRAC.1.6.TMP1000','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0100','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0130','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0126','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMPS0100','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0118','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP1001','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0114','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0112','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMPS0101','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0120','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0102','TMPWarnTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0119','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0131','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0133','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP1002','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP7','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0107','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0121','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0113','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0110','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0116','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0134','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0122','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP1003','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0115','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0104','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0103','TMPCriticalTrigger','ThermalSensor,ThermalMetrics'),
      ('iDRAC.1.6.TMP0202','TMPCpuWarnTrigger','CUPS,CPUSensor'),
      ('iDRAC.1.6.TMP0200','TMPCpuWarnTrigger','CUPS,CPUSensor'),
      ('iDRAC.1.6.MEM0003','MEMCriticalTrigger','MemorySensor'),
      ('iDRAC.1.6.MEM0010','MEMCriticalTrigger','MemorySensor'),
      ('iDRAC.1.6.MEM0702','MEMCriticalTrigger','MemorySensor'),
      ('iDRAC.1.6.MEM0002','MEMCriticalTrigger','MemorySensor'),
      ('iDRAC.1.6.TMP0127','TMPDiskCriticalTrigger','ThermalMetrics'),
      ('iDRAC.1.6.TMP0125','TMPDiskCriticalTrigger','ThermalMetrics'),
      ('iDRAC.1.6.TMP0128','TMPDiskCriticalTrigger','ThermalMetrics'),
      ('iDRAC.1.6.MEM0701','MEMWarnTrigger','MemorySensor'),
      ('iDRAC.1.6.PDR112','NVMeWarnTrigger','NVMeSMARTData'),
      ('iDRAC.1.6.PDR113','NVMeWarnTrigger','NVMeSMARTData'),
      ('iDRAC.1.6.PDR116','NVMeWarnTrigger','NVMeSMARTData'),
      ('iDRAC.1.6.FAN0012','FANWarnTrigger','FanSensor'),
      ('iDRAC.1.6.FAN0002','FANWarnTrigger','FanSensor'),
      ('iDRAC.1.6.FAN0000','FANWarnTrigger','FanSensor'),
      ('iDRAC.1.6.FAN0013','FANCriticalTrigger','FanSensor'),
      ('iDRAC.1.6.FAN0016','FANCriticalTrigger','FanSensor'),
      ('iDRAC.1.6.FAN0003','FANCriticalTrigger','FanSensor'),
      ('iDRAC.1.6.FAN0004','FANCriticalTrigger','FanSensor'),     
      ('iDRAC.1.6.FAN0015','FANCriticalTrigger','FanSensor'),
      ('iDRAC.1.6.FAN0001','FANCriticalTrigger','FanSensor'),
      ('iDRAC.1.6.VLT0210','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0231','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0104','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0204','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0209','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0207','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0219','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0203','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0303','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0234','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0227','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0216','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0201','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0233','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0225','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0301','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0304','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0222','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0215','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0213','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0228','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.VLT0221','VLTCriticalTrigger','PSUMetrics'),
      ('iDRAC.1.6.TMP0204','TMPCpuCriticalTrigger','CUPS,CPUSensor'),
      ('iDRAC.1.6.TMP0201','TMPCpuCriticalTrigger','CUPS,CPUSensor'),
      ('iDRAC.1.6.TMP0203','TMPCpuCriticalTrigger','CUPS,CPUSensor'),
      ('iDRAC.1.6.CPU0010','CPUWarnTrigger','CPUSensor'),
      ('iDRAC.1.6.PDR64','PDRCriticalTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR44','PDRCriticalTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR63','PDRCriticalTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR62','PDRCriticalTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR46','PDRCriticalTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR61','PDRCriticalTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR57','PDRCriticalTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR47','PDRCriticalTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR73','PDRCriticalTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.TMP0124','TMPDiskWarnTrigger','ThermalMetrics'),
      ('iDRAC.1.6.CPU0004','CPUCriticalTrigger','CPUSensor'),
      ('iDRAC.1.6.CPU0700','CPUCriticalTrigger','CPUSensor'),
      ('iDRAC.1.6.CPU0702','CPUCriticalTrigger','CPUSensor'),
      ('iDRAC.1.6.CPU0006','CPUCriticalTrigger','CPUSensor'),
      ('iDRAC.1.6.CPU0703','CPUCriticalTrigger','CPUSensor'),
      ('iDRAC.1.6.CPU0701','CPUCriticalTrigger','CPUSensor'),
      ('iDRAC.1.6.CPU0003','CPUCriticalTrigger','CPUSensor'),
      ('iDRAC.1.6.PDR1102','PDRWarnTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR86','PDRWarnTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR1002','PDRWarnTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR16','PDRWarnTrigger','StorageDiskSMARTData'),
      ('iDRAC.1.6.PDR117','NVMeCriticalTrigger','NVMeSMARTData'),
      ('iDRAC.1.6.CPU0000','IERRCriticalTrigger','CPURegisters');     
  
  # Table poplauted at metric-egine start by reading MD jsons   
  - |
     DROP TABLE IF EXISTS MetricDefinition;
     CREATE TABLE MetricDefinition
     (
       ID              INTEGER PRIMARY KEY,
       MetricId        TEXT UNIQUE NOT NULL,
       Name            TEXT NOT NULL,
       Description     TEXT NOT NULL,
       MetricType      TEXT NOT NULL,
       MetricDataType  TEXT NOT NULL,
       Units 	       TEXT, 
       Accuracy        REAL,
       SensingInterval TEXT,
       DiscreteValues  TEXT
     );    
  
  - |
     DROP VIEW IF EXISTS MetricDefinition_JSON;
     CREATE VIEW MetricDefinition_JSON as 
      SELECT 
      (
       '{' ||
       ' "@odata.type": "#MetricDefinition.v1_2_0.MetricDefinition",' ||
       ' "@odata.context": "/redfish/v1/$metadata#MetricDefinition.MetricDefinition",' ||
       ' "@odata.id": "/redfish/v1/TelemetryService/MetricDefinitions/' || MetricId || '",' ||
       ' "Id": "' || MetricId || '",' ||
       ' "Name": "' || Name || '",' ||
       ' "Description": "' || Description || '",' ||
       ' "MetricType": "' || MetricType || '",' ||
       ' "MetricDataType": "' || MetricDataType || '",' ||
       CASE WHEN Units = '' THEN '' ELSE ' "Units": "' || Units || '",'  END ||
       ' "Accuracy": ' || Accuracy || ',' ||
       ' "SensingInterval": "' || SensingInterval || '"' ||
       CASE WHEN DiscreteValues LIKE 'null' THEN '' ELSE ', "DiscreteValues": ' || DiscreteValues END ||
       '}'
       ) AS root,
            '/redfish/v1/TelemetryService/MetricDefinitions/' || MetricId AS [@odata.id]
       FROM MetricDefinition;

  - |
     DROP VIEW IF EXISTS MetricDefinitionCollection_JSON;
     CREATE VIEW MetricDefinitionCollection_JSON as
      select
       json_object(
        "@odata.context", "/redfish/v1/$metadata#MetricDefinitionCollection.MetricDefinitionCollection",
        "@odata.id", "/redfish/v1/TelemetryService/MetricDefinitions",
        "@odata.type", "#MetricDefinitionCollection.MetricDefinitionCollection",
        "Name", "MetricDefinitions",
        'Members', (
          select
            json_group_array( json_object('@odata.id', [@odata.id]) )
            from MetricDefinition_JSON
        )
       ) as root,
            '/redfish/v1/TelemetryService/MetricDefinitions' as [@odata.id];
     
  - |
        DROP VIEW IF EXISTS AggregationMetricsMRView_json ; create view AggregationMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/AggregationMetrics';
        DROP VIEW IF EXISTS CPUMemMetricsMRView_json ; create view CPUMemMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/CPUMemMetrics';
        DROP VIEW IF EXISTS CPURegistersMRView_json ; create view CPURegistersMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/CPURegisters';
        DROP VIEW IF EXISTS CPUSensorMRView_json ; create view CPUSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/CPUSensor';
        DROP VIEW IF EXISTS CUPSMRView_json ; create view CUPSMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/CUPS';
        DROP VIEW IF EXISTS FCSensorMRView_json ; create view FCSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/FCSensor';
        DROP VIEW IF EXISTS FPGASensorMRView_json ; create view FPGASensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/FPGASensor';
        DROP VIEW IF EXISTS FanSensorMRView_json ; create view FanSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/FanSensor';
        DROP VIEW IF EXISTS GPUMetricsMRView_json ; create view GPUMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/GPUMetrics';
        DROP VIEW IF EXISTS GPUStatisticsMRView_json ; create view GPUStatisticsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/GPUStatistics';
        DROP VIEW IF EXISTS MemorySensorMRView_json ; create view MemorySensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/MemorySensor';
        DROP VIEW IF EXISTS NICSensorMRView_json ; create view NICSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/NICSensor';
        DROP VIEW IF EXISTS NICStatisticsMRView_json ; create view NICStatisticsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/NICStatistics';
        DROP VIEW IF EXISTS NVMeSMARTDataMRView_json ; create view NVMeSMARTDataMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/NVMeSMARTData';
        DROP VIEW IF EXISTS PSUMetricsMRView_json ; create view PSUMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/PSUMetrics';
        DROP VIEW IF EXISTS PowerMetricsMRView_json ; create view PowerMetricsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/PowerMetrics';
        DROP VIEW IF EXISTS PowerStatisticsMRView_json ; create view PowerStatisticsMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/PowerStatistics';
        DROP VIEW IF EXISTS SensorMRView_json ; create view SensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/Sensor';
        DROP VIEW IF EXISTS StorageDiskSMARTDataMRView_json ; create view StorageDiskSMARTDataMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/StorageDiskSMARTData';
        DROP VIEW IF EXISTS StorageSensorMRView_json ; create view StorageSensorMRView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/StorageSensor';
        DROP VIEW IF EXISTS ThermalSensorMRView_json ; create view ThermalSensorMRView_json as select * from  JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/ThermalSensor';
        DROP VIEW IF EXISTS ThermalMetricsMRView_json ; create view ThermalMetricsMRView_json as select * from  JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports/ThermalMetrics';

        DROP VIEW IF EXISTS MetricReportCollectionView_json ; create view MetricReportCollectionView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReports';
        DROP VIEW IF EXISTS MetricReportDefinitionCollectionView_json ; create view MetricReportDefinitionCollectionView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService/MetricReportDefinitions';
        DROP VIEW IF EXISTS TelemetryServiceView_json ; create view TelemetryServiceView_json as select * from JSON where [@odata.id] = '/redfish/v1/TelemetryService';

        DROP VIEW IF EXISTS MetricDefinitionCollectionView_json ; create view MetricDefinitionCollectionView_json as select * from JSON  where [@odata.id] = '/redfish/v1/TelemetryService/MetricDefinitions';
        DROP VIEW IF EXISTS MetricDefinitionView_json ;           create view MetricDefinitionView_json as select * from JSON;
        DROP VIEW IF EXISTS TelemetryLogServiceLCLogview_json ;   -- create view TelemetryLogServiceLCLogview_json as select * from JSON;

# Logging levels:
# debug, info, warn, error, crit
#
# The 'logs' config is an ARRAY of output configurations. Below are the valid configuration options for each config.
#
# Enabled: disable or enable this specific logger entirely.
#       DEFAULT: disabled/false
#
# FileName: Specify "FileName" to send log output from that config to a file.
#       DEFAULT: /dev/stderr
#
# Level: will globally enable all logs at the specified level or higher. Leave this out to specify on a module by module basis
#       DEFAULT: (none) - no filtering, all logs output
#
# PrintFile: append the file name and line number of the location where the log function was called
#       DEFAULT: false
#
# PrintFunction: append the name of the function that called the log function
#       DEFAULT: false
#
# ModulesToEnable is an ARRAY
#   give 'name' to specify the name of a 'module', to show all output from all log statements tagged with that module (regardless of the global log level setting)
#   give 'level' to filter the module output to the specified log level and higher.
#
logs:
    # Log warnings and Crit to stderr (everything else to log file, below)
    - Enabled: true
      Level: "warn"
      PrintFile: true
      PrintFunction: true
      ModulesToEnable:
        - name: "LegacyARSync"
          level: "info"
        - name: "ReportGeneration"
          level: "info"

    # log all web server accesses
    - Enabled: false
      Level: "debug"
      FileName: "debug.log"
      PrintFile: true
      PrintFunction: true

    # (DISABLED) log stuff on a module by module basis to FILE
    - Enabled: false
      FileName: "/var/log/metric-engine.log"
      Level: "debug"
      PrintFile: true
      PrintFunction: true
      ModulesToEnable:
        # all of the loggers below support a heirarchical arrangement where
        # you can turn on debugging for all modules with (eg.)
        # "Managers/CMC.Integrated", and you can selectively enable
        # debugging for a single module by adding the full fqdd, eg.
        # "Managers/CMC.Integrated.1". For the template config, we only
        # specify the top levels
        - name: "Managers/CMC.Integrated"
          level: "crit"



